// @generated by protoc-gen-es v0.2.1 with parameter "target=ts"
// @generated from file tests/harness/cases/repeated.proto (package tests.harness.cases, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Any, Duration, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Embed as Embed$1 } from "./other_package/embed_pb.js";

/**
 * @generated from enum tests.harness.cases.AnEnum
 */
export enum AnEnum {
  /**
   * @generated from enum value: X = 0;
   */
  X = 0,

  /**
   * @generated from enum value: Y = 1;
   */
  Y = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(AnEnum)
proto3.util.setEnumType(AnEnum, "tests.harness.cases.AnEnum", [
  { no: 0, name: "X" },
  { no: 1, name: "Y" },
]);

/**
 * @generated from message tests.harness.cases.Embed
 */
export class Embed extends Message<Embed> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Embed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Embed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Embed {
    return new Embed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Embed {
    return new Embed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Embed {
    return new Embed().fromJsonString(jsonString, options);
  }

  static equals(a: Embed | PlainMessage<Embed> | undefined, b: Embed | PlainMessage<Embed> | undefined): boolean {
    return proto3.util.equals(Embed, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedNone
 */
export class RepeatedNone extends Message<RepeatedNone> {
  /**
   * @generated from field: repeated int64 val = 1;
   */
  val: bigint[] = [];

  constructor(data?: PartialMessage<RepeatedNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedNone {
    return new RepeatedNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedNone {
    return new RepeatedNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedNone {
    return new RepeatedNone().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedNone | PlainMessage<RepeatedNone> | undefined,
    b: RepeatedNone | PlainMessage<RepeatedNone> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedEmbedNone
 */
export class RepeatedEmbedNone extends Message<RepeatedEmbedNone> {
  /**
   * @generated from field: repeated tests.harness.cases.Embed val = 1;
   */
  val: Embed[] = [];

  constructor(data?: PartialMessage<RepeatedEmbedNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEmbedNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Embed, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEmbedNone {
    return new RepeatedEmbedNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEmbedNone {
    return new RepeatedEmbedNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEmbedNone {
    return new RepeatedEmbedNone().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEmbedNone | PlainMessage<RepeatedEmbedNone> | undefined,
    b: RepeatedEmbedNone | PlainMessage<RepeatedEmbedNone> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEmbedNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedEmbedCrossPackageNone
 */
export class RepeatedEmbedCrossPackageNone extends Message<RepeatedEmbedCrossPackageNone> {
  /**
   * @generated from field: repeated tests.harness.cases.other_package.Embed val = 1;
   */
  val: Embed$1[] = [];

  constructor(data?: PartialMessage<RepeatedEmbedCrossPackageNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEmbedCrossPackageNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Embed$1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEmbedCrossPackageNone {
    return new RepeatedEmbedCrossPackageNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEmbedCrossPackageNone {
    return new RepeatedEmbedCrossPackageNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEmbedCrossPackageNone {
    return new RepeatedEmbedCrossPackageNone().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEmbedCrossPackageNone | PlainMessage<RepeatedEmbedCrossPackageNone> | undefined,
    b: RepeatedEmbedCrossPackageNone | PlainMessage<RepeatedEmbedCrossPackageNone> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEmbedCrossPackageNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedMin
 */
export class RepeatedMin extends Message<RepeatedMin> {
  /**
   * @generated from field: repeated tests.harness.cases.Embed val = 1;
   */
  val: Embed[] = [];

  constructor(data?: PartialMessage<RepeatedMin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedMin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Embed, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedMin {
    return new RepeatedMin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedMin {
    return new RepeatedMin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedMin {
    return new RepeatedMin().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedMin | PlainMessage<RepeatedMin> | undefined,
    b: RepeatedMin | PlainMessage<RepeatedMin> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedMin, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedMax
 */
export class RepeatedMax extends Message<RepeatedMax> {
  /**
   * @generated from field: repeated double val = 1;
   */
  val: number[] = [];

  constructor(data?: PartialMessage<RepeatedMax>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedMax";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedMax {
    return new RepeatedMax().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedMax {
    return new RepeatedMax().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedMax {
    return new RepeatedMax().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedMax | PlainMessage<RepeatedMax> | undefined,
    b: RepeatedMax | PlainMessage<RepeatedMax> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedMax, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedMinMax
 */
export class RepeatedMinMax extends Message<RepeatedMinMax> {
  /**
   * @generated from field: repeated sfixed32 val = 1;
   */
  val: number[] = [];

  constructor(data?: PartialMessage<RepeatedMinMax>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedMinMax";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedMinMax {
    return new RepeatedMinMax().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedMinMax {
    return new RepeatedMinMax().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedMinMax {
    return new RepeatedMinMax().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedMinMax | PlainMessage<RepeatedMinMax> | undefined,
    b: RepeatedMinMax | PlainMessage<RepeatedMinMax> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedMinMax, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedExact
 */
export class RepeatedExact extends Message<RepeatedExact> {
  /**
   * @generated from field: repeated uint32 val = 1;
   */
  val: number[] = [];

  constructor(data?: PartialMessage<RepeatedExact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedExact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedExact {
    return new RepeatedExact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedExact {
    return new RepeatedExact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedExact {
    return new RepeatedExact().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedExact | PlainMessage<RepeatedExact> | undefined,
    b: RepeatedExact | PlainMessage<RepeatedExact> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedExact, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedUnique
 */
export class RepeatedUnique extends Message<RepeatedUnique> {
  /**
   * @generated from field: repeated string val = 1;
   */
  val: string[] = [];

  constructor(data?: PartialMessage<RepeatedUnique>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedUnique";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedUnique {
    return new RepeatedUnique().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedUnique {
    return new RepeatedUnique().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedUnique {
    return new RepeatedUnique().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedUnique | PlainMessage<RepeatedUnique> | undefined,
    b: RepeatedUnique | PlainMessage<RepeatedUnique> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedUnique, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedItemRule
 */
export class RepeatedItemRule extends Message<RepeatedItemRule> {
  /**
   * @generated from field: repeated float val = 1;
   */
  val: number[] = [];

  constructor(data?: PartialMessage<RepeatedItemRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedItemRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedItemRule {
    return new RepeatedItemRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedItemRule {
    return new RepeatedItemRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedItemRule {
    return new RepeatedItemRule().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedItemRule | PlainMessage<RepeatedItemRule> | undefined,
    b: RepeatedItemRule | PlainMessage<RepeatedItemRule> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedItemRule, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedItemPattern
 */
export class RepeatedItemPattern extends Message<RepeatedItemPattern> {
  /**
   * @generated from field: repeated string val = 1;
   */
  val: string[] = [];

  constructor(data?: PartialMessage<RepeatedItemPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedItemPattern";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedItemPattern {
    return new RepeatedItemPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedItemPattern {
    return new RepeatedItemPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedItemPattern {
    return new RepeatedItemPattern().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedItemPattern | PlainMessage<RepeatedItemPattern> | undefined,
    b: RepeatedItemPattern | PlainMessage<RepeatedItemPattern> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedItemPattern, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedEmbedSkip
 */
export class RepeatedEmbedSkip extends Message<RepeatedEmbedSkip> {
  /**
   * @generated from field: repeated tests.harness.cases.Embed val = 1;
   */
  val: Embed[] = [];

  constructor(data?: PartialMessage<RepeatedEmbedSkip>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEmbedSkip";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Embed, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEmbedSkip {
    return new RepeatedEmbedSkip().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEmbedSkip {
    return new RepeatedEmbedSkip().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEmbedSkip {
    return new RepeatedEmbedSkip().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEmbedSkip | PlainMessage<RepeatedEmbedSkip> | undefined,
    b: RepeatedEmbedSkip | PlainMessage<RepeatedEmbedSkip> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEmbedSkip, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedItemIn
 */
export class RepeatedItemIn extends Message<RepeatedItemIn> {
  /**
   * @generated from field: repeated string val = 1;
   */
  val: string[] = [];

  constructor(data?: PartialMessage<RepeatedItemIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedItemIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedItemIn {
    return new RepeatedItemIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedItemIn {
    return new RepeatedItemIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedItemIn {
    return new RepeatedItemIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedItemIn | PlainMessage<RepeatedItemIn> | undefined,
    b: RepeatedItemIn | PlainMessage<RepeatedItemIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedItemIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedItemNotIn
 */
export class RepeatedItemNotIn extends Message<RepeatedItemNotIn> {
  /**
   * @generated from field: repeated string val = 1;
   */
  val: string[] = [];

  constructor(data?: PartialMessage<RepeatedItemNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedItemNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedItemNotIn {
    return new RepeatedItemNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedItemNotIn {
    return new RepeatedItemNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedItemNotIn {
    return new RepeatedItemNotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedItemNotIn | PlainMessage<RepeatedItemNotIn> | undefined,
    b: RepeatedItemNotIn | PlainMessage<RepeatedItemNotIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedItemNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedEnumIn
 */
export class RepeatedEnumIn extends Message<RepeatedEnumIn> {
  /**
   * @generated from field: repeated tests.harness.cases.AnEnum val = 1;
   */
  val: AnEnum[] = [];

  constructor(data?: PartialMessage<RepeatedEnumIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEnumIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "enum", T: proto3.getEnumType(AnEnum), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEnumIn {
    return new RepeatedEnumIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEnumIn {
    return new RepeatedEnumIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEnumIn {
    return new RepeatedEnumIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEnumIn | PlainMessage<RepeatedEnumIn> | undefined,
    b: RepeatedEnumIn | PlainMessage<RepeatedEnumIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEnumIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedEnumNotIn
 */
export class RepeatedEnumNotIn extends Message<RepeatedEnumNotIn> {
  /**
   * @generated from field: repeated tests.harness.cases.AnEnum val = 1;
   */
  val: AnEnum[] = [];

  constructor(data?: PartialMessage<RepeatedEnumNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEnumNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "enum", T: proto3.getEnumType(AnEnum), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEnumNotIn {
    return new RepeatedEnumNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEnumNotIn {
    return new RepeatedEnumNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEnumNotIn {
    return new RepeatedEnumNotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEnumNotIn | PlainMessage<RepeatedEnumNotIn> | undefined,
    b: RepeatedEnumNotIn | PlainMessage<RepeatedEnumNotIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEnumNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedEmbeddedEnumIn
 */
export class RepeatedEmbeddedEnumIn extends Message<RepeatedEmbeddedEnumIn> {
  /**
   * @generated from field: repeated tests.harness.cases.RepeatedEmbeddedEnumIn.AnotherInEnum val = 1;
   */
  val: RepeatedEmbeddedEnumIn_AnotherInEnum[] = [];

  constructor(data?: PartialMessage<RepeatedEmbeddedEnumIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEmbeddedEnumIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "enum", T: proto3.getEnumType(RepeatedEmbeddedEnumIn_AnotherInEnum), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEmbeddedEnumIn {
    return new RepeatedEmbeddedEnumIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEmbeddedEnumIn {
    return new RepeatedEmbeddedEnumIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEmbeddedEnumIn {
    return new RepeatedEmbeddedEnumIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEmbeddedEnumIn | PlainMessage<RepeatedEmbeddedEnumIn> | undefined,
    b: RepeatedEmbeddedEnumIn | PlainMessage<RepeatedEmbeddedEnumIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEmbeddedEnumIn, a, b);
  }
}

/**
 * @generated from enum tests.harness.cases.RepeatedEmbeddedEnumIn.AnotherInEnum
 */
export enum RepeatedEmbeddedEnumIn_AnotherInEnum {
  /**
   * @generated from enum value: A = 0;
   */
  A = 0,

  /**
   * @generated from enum value: B = 1;
   */
  B = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RepeatedEmbeddedEnumIn_AnotherInEnum)
proto3.util.setEnumType(
  RepeatedEmbeddedEnumIn_AnotherInEnum,
  "tests.harness.cases.RepeatedEmbeddedEnumIn.AnotherInEnum",
  [
    { no: 0, name: "A" },
    { no: 1, name: "B" },
  ]
);

/**
 * @generated from message tests.harness.cases.RepeatedEmbeddedEnumNotIn
 */
export class RepeatedEmbeddedEnumNotIn extends Message<RepeatedEmbeddedEnumNotIn> {
  /**
   * @generated from field: repeated tests.harness.cases.RepeatedEmbeddedEnumNotIn.AnotherNotInEnum val = 1;
   */
  val: RepeatedEmbeddedEnumNotIn_AnotherNotInEnum[] = [];

  constructor(data?: PartialMessage<RepeatedEmbeddedEnumNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedEmbeddedEnumNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "enum",
      T: proto3.getEnumType(RepeatedEmbeddedEnumNotIn_AnotherNotInEnum),
      repeated: true,
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedEmbeddedEnumNotIn {
    return new RepeatedEmbeddedEnumNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedEmbeddedEnumNotIn {
    return new RepeatedEmbeddedEnumNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedEmbeddedEnumNotIn {
    return new RepeatedEmbeddedEnumNotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedEmbeddedEnumNotIn | PlainMessage<RepeatedEmbeddedEnumNotIn> | undefined,
    b: RepeatedEmbeddedEnumNotIn | PlainMessage<RepeatedEmbeddedEnumNotIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedEmbeddedEnumNotIn, a, b);
  }
}

/**
 * @generated from enum tests.harness.cases.RepeatedEmbeddedEnumNotIn.AnotherNotInEnum
 */
export enum RepeatedEmbeddedEnumNotIn_AnotherNotInEnum {
  /**
   * @generated from enum value: A = 0;
   */
  A = 0,

  /**
   * @generated from enum value: B = 1;
   */
  B = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RepeatedEmbeddedEnumNotIn_AnotherNotInEnum)
proto3.util.setEnumType(
  RepeatedEmbeddedEnumNotIn_AnotherNotInEnum,
  "tests.harness.cases.RepeatedEmbeddedEnumNotIn.AnotherNotInEnum",
  [
    { no: 0, name: "A" },
    { no: 1, name: "B" },
  ]
);

/**
 * @generated from message tests.harness.cases.RepeatedAnyIn
 */
export class RepeatedAnyIn extends Message<RepeatedAnyIn> {
  /**
   * @generated from field: repeated google.protobuf.Any val = 1;
   */
  val: Any[] = [];

  constructor(data?: PartialMessage<RepeatedAnyIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedAnyIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Any, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedAnyIn {
    return new RepeatedAnyIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedAnyIn {
    return new RepeatedAnyIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedAnyIn {
    return new RepeatedAnyIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedAnyIn | PlainMessage<RepeatedAnyIn> | undefined,
    b: RepeatedAnyIn | PlainMessage<RepeatedAnyIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedAnyIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedAnyNotIn
 */
export class RepeatedAnyNotIn extends Message<RepeatedAnyNotIn> {
  /**
   * @generated from field: repeated google.protobuf.Any val = 1;
   */
  val: Any[] = [];

  constructor(data?: PartialMessage<RepeatedAnyNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedAnyNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Any, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedAnyNotIn {
    return new RepeatedAnyNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedAnyNotIn {
    return new RepeatedAnyNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedAnyNotIn {
    return new RepeatedAnyNotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedAnyNotIn | PlainMessage<RepeatedAnyNotIn> | undefined,
    b: RepeatedAnyNotIn | PlainMessage<RepeatedAnyNotIn> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedAnyNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedMinAndItemLen
 */
export class RepeatedMinAndItemLen extends Message<RepeatedMinAndItemLen> {
  /**
   * @generated from field: repeated string val = 1;
   */
  val: string[] = [];

  constructor(data?: PartialMessage<RepeatedMinAndItemLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedMinAndItemLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedMinAndItemLen {
    return new RepeatedMinAndItemLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedMinAndItemLen {
    return new RepeatedMinAndItemLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedMinAndItemLen {
    return new RepeatedMinAndItemLen().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedMinAndItemLen | PlainMessage<RepeatedMinAndItemLen> | undefined,
    b: RepeatedMinAndItemLen | PlainMessage<RepeatedMinAndItemLen> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedMinAndItemLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedMinAndMaxItemLen
 */
export class RepeatedMinAndMaxItemLen extends Message<RepeatedMinAndMaxItemLen> {
  /**
   * @generated from field: repeated string val = 1;
   */
  val: string[] = [];

  constructor(data?: PartialMessage<RepeatedMinAndMaxItemLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedMinAndMaxItemLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedMinAndMaxItemLen {
    return new RepeatedMinAndMaxItemLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedMinAndMaxItemLen {
    return new RepeatedMinAndMaxItemLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedMinAndMaxItemLen {
    return new RepeatedMinAndMaxItemLen().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedMinAndMaxItemLen | PlainMessage<RepeatedMinAndMaxItemLen> | undefined,
    b: RepeatedMinAndMaxItemLen | PlainMessage<RepeatedMinAndMaxItemLen> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedMinAndMaxItemLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedDuration
 */
export class RepeatedDuration extends Message<RepeatedDuration> {
  /**
   * @generated from field: repeated google.protobuf.Duration val = 1;
   */
  val: Duration[] = [];

  constructor(data?: PartialMessage<RepeatedDuration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedDuration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Duration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedDuration {
    return new RepeatedDuration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedDuration {
    return new RepeatedDuration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedDuration {
    return new RepeatedDuration().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedDuration | PlainMessage<RepeatedDuration> | undefined,
    b: RepeatedDuration | PlainMessage<RepeatedDuration> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedDuration, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.RepeatedExactIgnore
 */
export class RepeatedExactIgnore extends Message<RepeatedExactIgnore> {
  /**
   * @generated from field: repeated uint32 val = 1;
   */
  val: number[] = [];

  constructor(data?: PartialMessage<RepeatedExactIgnore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.RepeatedExactIgnore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedExactIgnore {
    return new RepeatedExactIgnore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedExactIgnore {
    return new RepeatedExactIgnore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedExactIgnore {
    return new RepeatedExactIgnore().fromJsonString(jsonString, options);
  }

  static equals(
    a: RepeatedExactIgnore | PlainMessage<RepeatedExactIgnore> | undefined,
    b: RepeatedExactIgnore | PlainMessage<RepeatedExactIgnore> | undefined
  ): boolean {
    return proto3.util.equals(RepeatedExactIgnore, a, b);
  }
}
