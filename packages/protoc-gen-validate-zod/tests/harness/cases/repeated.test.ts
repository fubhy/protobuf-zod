// @generated by protoc-gen-validate-zod-test v0.0.1-dev with parameter "target=ts,cases=tests/fixtures/cases.txt"
// @generated from file tests/harness/cases/repeated.proto (package tests.harness.cases, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import { expect, it } from "vitest";
import {
  RepeatedAnyIn,
  RepeatedAnyNotIn,
  RepeatedDuration,
  RepeatedEmbedCrossPackageNone,
  RepeatedEmbeddedEnumIn,
  RepeatedEmbeddedEnumNotIn,
  RepeatedEmbedNone,
  RepeatedEmbedSkip,
  RepeatedEnumIn,
  RepeatedEnumNotIn,
  RepeatedExact,
  RepeatedExactIgnore,
  RepeatedItemIn,
  RepeatedItemNotIn,
  RepeatedItemPattern,
  RepeatedItemRule,
  RepeatedMax,
  RepeatedMin,
  RepeatedMinAndItemLen,
  RepeatedMinAndMaxItemLen,
  RepeatedMinMax,
  RepeatedNone,
  RepeatedUnique,
} from "./repeated_pb.js";
import {
  RepeatedAnyInSchema,
  RepeatedAnyNotInSchema,
  RepeatedDurationSchema,
  RepeatedEmbedCrossPackageNoneSchema,
  RepeatedEmbeddedEnumInSchema,
  RepeatedEmbeddedEnumNotInSchema,
  RepeatedEmbedNoneSchema,
  RepeatedEmbedSkipSchema,
  RepeatedEnumInSchema,
  RepeatedEnumNotInSchema,
  RepeatedExactIgnoreSchema,
  RepeatedExactSchema,
  RepeatedItemInSchema,
  RepeatedItemNotInSchema,
  RepeatedItemPatternSchema,
  RepeatedItemRuleSchema,
  RepeatedMaxSchema,
  RepeatedMinAndItemLenSchema,
  RepeatedMinAndMaxItemLenSchema,
  RepeatedMinMaxSchema,
  RepeatedMinSchema,
  RepeatedNoneSchema,
  RepeatedUniqueSchema,
} from "./repeated_zod.js";

it("repeated - none - valid", () => {
  const message = RepeatedNone.fromJson({ val: ["1", "2", "3"] });
  expect(message).toBeValid(RepeatedNoneSchema);
});

it("repeated - embed none - valid", () => {
  const message = RepeatedEmbedNone.fromJson({ val: [{ val: "1" }] });
  expect(message).toBeValid(RepeatedEmbedNoneSchema);
});

it("repeated - embed none - valid (nil)", () => {
  const message = RepeatedEmbedNone.fromJson({});
  expect(message).toBeValid(RepeatedEmbedNoneSchema);
});

it("repeated - embed none - valid (empty)", () => {
  const message = RepeatedEmbedNone.fromJson({});
  expect(message).toBeValid(RepeatedEmbedNoneSchema);
});

it("repeated - embed none - invalid", () => {
  const message = RepeatedEmbedNone.fromJson({ val: [{ val: "-1" }] });
  expect(message).toBeInvalid(RepeatedEmbedNoneSchema, 1);
});

it("repeated - cross-package embed none - valid", () => {
  const message = RepeatedEmbedCrossPackageNone.fromJson({ val: [{ val: "1" }] });
  expect(message).toBeValid(RepeatedEmbedCrossPackageNoneSchema);
});

it("repeated - cross-package embed none - valid (nil)", () => {
  const message = RepeatedEmbedCrossPackageNone.fromJson({});
  expect(message).toBeValid(RepeatedEmbedCrossPackageNoneSchema);
});

it("repeated - cross-package embed none - valid (empty)", () => {
  const message = RepeatedEmbedCrossPackageNone.fromJson({});
  expect(message).toBeValid(RepeatedEmbedCrossPackageNoneSchema);
});

it("repeated - cross-package embed none - invalid", () => {
  const message = RepeatedEmbedCrossPackageNone.fromJson({ val: [{ val: "-1" }] });
  expect(message).toBeInvalid(RepeatedEmbedCrossPackageNoneSchema, 1);
});

it("repeated - min - valid", () => {
  const message = RepeatedMin.fromJson({ val: [{ val: "1" }, { val: "2" }, { val: "3" }] });
  expect(message).toBeValid(RepeatedMinSchema);
});

it("repeated - min - valid (equal)", () => {
  const message = RepeatedMin.fromJson({ val: [{ val: "1" }, { val: "2" }] });
  expect(message).toBeValid(RepeatedMinSchema);
});

it("repeated - min - invalid", () => {
  const message = RepeatedMin.fromJson({ val: [{ val: "1" }] });
  expect(message).toBeInvalid(RepeatedMinSchema, 1);
});

it("repeated - min - invalid (element)", () => {
  const message = RepeatedMin.fromJson({ val: [{ val: "1" }, { val: "-1" }] });
  expect(message).toBeInvalid(RepeatedMinSchema, 1);
});

it("repeated - max - valid", () => {
  const message = RepeatedMax.fromJson({ val: [1, 2] });
  expect(message).toBeValid(RepeatedMaxSchema);
});

it("repeated - max - valid (equal)", () => {
  const message = RepeatedMax.fromJson({ val: [1, 2, 3] });
  expect(message).toBeValid(RepeatedMaxSchema);
});

it("repeated - max - invalid", () => {
  const message = RepeatedMax.fromJson({ val: [1, 2, 3, 4] });
  expect(message).toBeInvalid(RepeatedMaxSchema, 1);
});

it("repeated - min/max - valid", () => {
  const message = RepeatedMinMax.fromJson({ val: [1, 2, 3] });
  expect(message).toBeValid(RepeatedMinMaxSchema);
});

it("repeated - min/max - valid (min)", () => {
  const message = RepeatedMinMax.fromJson({ val: [1, 2] });
  expect(message).toBeValid(RepeatedMinMaxSchema);
});

it("repeated - min/max - valid (max)", () => {
  const message = RepeatedMinMax.fromJson({ val: [1, 2, 3, 4] });
  expect(message).toBeValid(RepeatedMinMaxSchema);
});

it("repeated - min/max - invalid (below)", () => {
  const message = RepeatedMinMax.fromJson({});
  expect(message).toBeInvalid(RepeatedMinMaxSchema, 1);
});

it("repeated - min/max - invalid (above)", () => {
  const message = RepeatedMinMax.fromJson({ val: [1, 2, 3, 4, 5] });
  expect(message).toBeInvalid(RepeatedMinMaxSchema, 1);
});

it("repeated - exact - valid", () => {
  const message = RepeatedExact.fromJson({ val: [1, 2, 3] });
  expect(message).toBeValid(RepeatedExactSchema);
});

it("repeated - exact - invalid (below)", () => {
  const message = RepeatedExact.fromJson({ val: [1, 2] });
  expect(message).toBeInvalid(RepeatedExactSchema, 1);
});

it("repeated - exact - invalid (above)", () => {
  const message = RepeatedExact.fromJson({ val: [1, 2, 3, 4] });
  expect(message).toBeInvalid(RepeatedExactSchema, 1);
});

it("repeated - unique - valid", () => {
  const message = RepeatedUnique.fromJson({ val: ["foo", "bar", "baz"] });
  expect(message).toBeValid(RepeatedUniqueSchema);
});

it("repeated - unique - valid (empty)", () => {
  const message = RepeatedUnique.fromJson({});
  expect(message).toBeValid(RepeatedUniqueSchema);
});

it("repeated - unique - valid (case sensitivity)", () => {
  const message = RepeatedUnique.fromJson({ val: ["foo", "Foo"] });
  expect(message).toBeValid(RepeatedUniqueSchema);
});

it("repeated - unique - invalid", () => {
  const message = RepeatedUnique.fromJson({ val: ["foo", "bar", "foo", "baz"] });
  expect(message).toBeInvalid(RepeatedUniqueSchema, 1);
});

it("repeated - items - valid", () => {
  const message = RepeatedItemRule.fromJson({ val: [1, 2, 3] });
  expect(message).toBeValid(RepeatedItemRuleSchema);
});

it("repeated - items - valid (empty)", () => {
  const message = RepeatedItemRule.fromJson({});
  expect(message).toBeValid(RepeatedItemRuleSchema);
});

it("repeated - items - valid (pattern)", () => {
  const message = RepeatedItemPattern.fromJson({ val: ["Alpha", "Beta123"] });
  expect(message).toBeValid(RepeatedItemPatternSchema);
});

it("repeated - items - invalid", () => {
  const message = RepeatedItemRule.fromJson({ val: [1, -2, 3] });
  expect(message).toBeInvalid(RepeatedItemRuleSchema, 1);
});

it("repeated - items - invalid (pattern)", () => {
  const message = RepeatedItemPattern.fromJson({ val: ["Alpha", "!@#$%^&*()"] });
  expect(message).toBeInvalid(RepeatedItemPatternSchema, 1);
});

it("repeated - items - invalid (in)", () => {
  const message = RepeatedItemIn.fromJson({ val: ["baz"] });
  expect(message).toBeInvalid(RepeatedItemInSchema, 1);
});

it("repeated - items - valid (in)", () => {
  const message = RepeatedItemIn.fromJson({ val: ["foo"] });
  expect(message).toBeValid(RepeatedItemInSchema);
});

it("repeated - items - invalid (not_in)", () => {
  const message = RepeatedItemNotIn.fromJson({ val: ["foo"] });
  expect(message).toBeInvalid(RepeatedItemNotInSchema, 1);
});

it("repeated - items - valid (not_in)", () => {
  const message = RepeatedItemNotIn.fromJson({ val: ["baz"] });
  expect(message).toBeValid(RepeatedItemNotInSchema);
});

it("repeated - items - invalid (enum in)", () => {
  const message = RepeatedEnumIn.fromJson({ val: ["Y"] });
  expect(message).toBeInvalid(RepeatedEnumInSchema, 1);
});

it("repeated - items - valid (enum in)", () => {
  const message = RepeatedEnumIn.fromJson({ val: ["X"] });
  expect(message).toBeValid(RepeatedEnumInSchema);
});

it("repeated - items - invalid (enum not_in)", () => {
  const message = RepeatedEnumNotIn.fromJson({ val: ["X"] });
  expect(message).toBeInvalid(RepeatedEnumNotInSchema, 1);
});

it("repeated - items - valid (enum not_in)", () => {
  const message = RepeatedEnumNotIn.fromJson({ val: ["Y"] });
  expect(message).toBeValid(RepeatedEnumNotInSchema);
});

it("repeated - items - invalid (embedded enum in)", () => {
  const message = RepeatedEmbeddedEnumIn.fromJson({ val: ["B"] });
  expect(message).toBeInvalid(RepeatedEmbeddedEnumInSchema, 1);
});

it("repeated - items - valid (embedded enum in)", () => {
  const message = RepeatedEmbeddedEnumIn.fromJson({ val: ["A"] });
  expect(message).toBeValid(RepeatedEmbeddedEnumInSchema);
});

it("repeated - items - invalid (embedded enum not_in)", () => {
  const message = RepeatedEmbeddedEnumNotIn.fromJson({ val: ["A"] });
  expect(message).toBeInvalid(RepeatedEmbeddedEnumNotInSchema, 1);
});

it("repeated - items - valid (embedded enum not_in)", () => {
  const message = RepeatedEmbeddedEnumNotIn.fromJson({ val: ["B"] });
  expect(message).toBeValid(RepeatedEmbeddedEnumNotInSchema);
});

it("repeated - items - invalid (any in)", () => {
  const message = RepeatedAnyIn.fromJson({
    val: [{ "@type": "type.googleapis.com/google.protobuf.Timestamp", value: "1970-01-01T00:00:00Z" }],
  });
  expect(message).toBeInvalid(RepeatedAnyInSchema, 1);
});

it("repeated - items - valid (any in)", () => {
  const message = RepeatedAnyIn.fromJson({
    val: [{ "@type": "type.googleapis.com/google.protobuf.Duration", value: "0s" }],
  });
  expect(message).toBeValid(RepeatedAnyInSchema);
});

it("repeated - items - invalid (any not_in)", () => {
  const message = RepeatedAnyNotIn.fromJson({
    val: [{ "@type": "type.googleapis.com/google.protobuf.Timestamp", value: "1970-01-01T00:00:00Z" }],
  });
  expect(message).toBeInvalid(RepeatedAnyNotInSchema, 1);
});

it("repeated - items - valid (any not_in)", () => {
  const message = RepeatedAnyNotIn.fromJson({
    val: [{ "@type": "type.googleapis.com/google.protobuf.Duration", value: "0s" }],
  });
  expect(message).toBeValid(RepeatedAnyNotInSchema);
});

it("repeated - embed skip - valid", () => {
  const message = RepeatedEmbedSkip.fromJson({ val: [{ val: "1" }] });
  expect(message).toBeValid(RepeatedEmbedSkipSchema);
});

it("repeated - embed skip - valid (invalid element)", () => {
  const message = RepeatedEmbedSkip.fromJson({ val: [{ val: "-1" }] });
  expect(message).toBeValid(RepeatedEmbedSkipSchema);
});

it("repeated - min and items len - valid", () => {
  const message = RepeatedMinAndItemLen.fromJson({ val: ["aaa", "bbb"] });
  expect(message).toBeValid(RepeatedMinAndItemLenSchema);
});

it("repeated - min and items len - invalid (min)", () => {
  const message = RepeatedMinAndItemLen.fromJson({});
  expect(message).toBeInvalid(RepeatedMinAndItemLenSchema, 1);
});

it("repeated - min and items len - invalid (len)", () => {
  const message = RepeatedMinAndItemLen.fromJson({ val: ["x"] });
  expect(message).toBeInvalid(RepeatedMinAndItemLenSchema, 1);
});

it("repeated - min and max items len - valid", () => {
  const message = RepeatedMinAndMaxItemLen.fromJson({ val: ["aaa", "bbb"] });
  expect(message).toBeValid(RepeatedMinAndMaxItemLenSchema);
});

it("repeated - min and max items len - invalid (min_len)", () => {
  const message = RepeatedMinAndMaxItemLen.fromJson({});
  expect(message).toBeInvalid(RepeatedMinAndMaxItemLenSchema, 1);
});

it("repeated - min and max items len - invalid (max_len)", () => {
  const message = RepeatedMinAndMaxItemLen.fromJson({ val: ["aaa", "bbb", "ccc", "ddd"] });
  expect(message).toBeInvalid(RepeatedMinAndMaxItemLenSchema, 1);
});

it("repeated - duration - gte - valid", () => {
  const message = RepeatedDuration.fromJson({ val: ["3s"] });
  expect(message).toBeValid(RepeatedDurationSchema);
});

it("repeated - duration - gte - valid (empty)", () => {
  const message = RepeatedDuration.fromJson({});
  expect(message).toBeValid(RepeatedDurationSchema);
});

it("repeated - duration - gte - valid (equal)", () => {
  const message = RepeatedDuration.fromJson({ val: ["0.001s"] });
  expect(message).toBeValid(RepeatedDurationSchema);
});

it("repeated - duration - gte - invalid", () => {
  const message = RepeatedDuration.fromJson({ val: ["-1s"] });
  expect(message).toBeInvalid(RepeatedDurationSchema, 1);
});

it("repeated - exact - valid (ignore_empty)", () => {
  const message = RepeatedExactIgnore.fromJson({});
  expect(message).toBeValid(RepeatedExactIgnoreSchema);
});
