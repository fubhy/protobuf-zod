// @generated by protoc-gen-es v0.2.1 with parameter "target=ts"
// @generated from file tests/harness/cases/numbers.proto (package tests.harness.cases, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message tests.harness.cases.FloatNone
 */
export class FloatNone extends Message<FloatNone> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatNone {
    return new FloatNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatNone {
    return new FloatNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatNone {
    return new FloatNone().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatNone | PlainMessage<FloatNone> | undefined,
    b: FloatNone | PlainMessage<FloatNone> | undefined
  ): boolean {
    return proto3.util.equals(FloatNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatConst
 */
export class FloatConst extends Message<FloatConst> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatConst>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatConst";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatConst {
    return new FloatConst().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatConst {
    return new FloatConst().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatConst {
    return new FloatConst().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatConst | PlainMessage<FloatConst> | undefined,
    b: FloatConst | PlainMessage<FloatConst> | undefined
  ): boolean {
    return proto3.util.equals(FloatConst, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatIn
 */
export class FloatIn extends Message<FloatIn> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatIn {
    return new FloatIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatIn {
    return new FloatIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatIn {
    return new FloatIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatIn | PlainMessage<FloatIn> | undefined,
    b: FloatIn | PlainMessage<FloatIn> | undefined
  ): boolean {
    return proto3.util.equals(FloatIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatNotIn
 */
export class FloatNotIn extends Message<FloatNotIn> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatNotIn {
    return new FloatNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatNotIn {
    return new FloatNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatNotIn {
    return new FloatNotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatNotIn | PlainMessage<FloatNotIn> | undefined,
    b: FloatNotIn | PlainMessage<FloatNotIn> | undefined
  ): boolean {
    return proto3.util.equals(FloatNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatLT
 */
export class FloatLT extends Message<FloatLT> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatLT {
    return new FloatLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatLT {
    return new FloatLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatLT {
    return new FloatLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatLT | PlainMessage<FloatLT> | undefined,
    b: FloatLT | PlainMessage<FloatLT> | undefined
  ): boolean {
    return proto3.util.equals(FloatLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatLTE
 */
export class FloatLTE extends Message<FloatLTE> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatLTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatLTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatLTE {
    return new FloatLTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatLTE {
    return new FloatLTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatLTE {
    return new FloatLTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatLTE | PlainMessage<FloatLTE> | undefined,
    b: FloatLTE | PlainMessage<FloatLTE> | undefined
  ): boolean {
    return proto3.util.equals(FloatLTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatGT
 */
export class FloatGT extends Message<FloatGT> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatGT {
    return new FloatGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatGT {
    return new FloatGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatGT {
    return new FloatGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatGT | PlainMessage<FloatGT> | undefined,
    b: FloatGT | PlainMessage<FloatGT> | undefined
  ): boolean {
    return proto3.util.equals(FloatGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatGTE
 */
export class FloatGTE extends Message<FloatGTE> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatGTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatGTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatGTE {
    return new FloatGTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatGTE {
    return new FloatGTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatGTE {
    return new FloatGTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatGTE | PlainMessage<FloatGTE> | undefined,
    b: FloatGTE | PlainMessage<FloatGTE> | undefined
  ): boolean {
    return proto3.util.equals(FloatGTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatGTLT
 */
export class FloatGTLT extends Message<FloatGTLT> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatGTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatGTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatGTLT {
    return new FloatGTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatGTLT {
    return new FloatGTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatGTLT {
    return new FloatGTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatGTLT | PlainMessage<FloatGTLT> | undefined,
    b: FloatGTLT | PlainMessage<FloatGTLT> | undefined
  ): boolean {
    return proto3.util.equals(FloatGTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatExLTGT
 */
export class FloatExLTGT extends Message<FloatExLTGT> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatExLTGT {
    return new FloatExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatExLTGT {
    return new FloatExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatExLTGT {
    return new FloatExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatExLTGT | PlainMessage<FloatExLTGT> | undefined,
    b: FloatExLTGT | PlainMessage<FloatExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(FloatExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatGTELTE
 */
export class FloatGTELTE extends Message<FloatGTELTE> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatGTELTE {
    return new FloatGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatGTELTE {
    return new FloatGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatGTELTE {
    return new FloatGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatGTELTE | PlainMessage<FloatGTELTE> | undefined,
    b: FloatGTELTE | PlainMessage<FloatGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(FloatGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatExGTELTE
 */
export class FloatExGTELTE extends Message<FloatExGTELTE> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatExGTELTE {
    return new FloatExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatExGTELTE {
    return new FloatExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatExGTELTE {
    return new FloatExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatExGTELTE | PlainMessage<FloatExGTELTE> | undefined,
    b: FloatExGTELTE | PlainMessage<FloatExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(FloatExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.FloatIgnore
 */
export class FloatIgnore extends Message<FloatIgnore> {
  /**
   * @generated from field: float val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<FloatIgnore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.FloatIgnore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatIgnore {
    return new FloatIgnore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatIgnore {
    return new FloatIgnore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatIgnore {
    return new FloatIgnore().fromJsonString(jsonString, options);
  }

  static equals(
    a: FloatIgnore | PlainMessage<FloatIgnore> | undefined,
    b: FloatIgnore | PlainMessage<FloatIgnore> | undefined
  ): boolean {
    return proto3.util.equals(FloatIgnore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleNone
 */
export class DoubleNone extends Message<DoubleNone> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleNone {
    return new DoubleNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleNone {
    return new DoubleNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleNone {
    return new DoubleNone().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleNone | PlainMessage<DoubleNone> | undefined,
    b: DoubleNone | PlainMessage<DoubleNone> | undefined
  ): boolean {
    return proto3.util.equals(DoubleNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleConst
 */
export class DoubleConst extends Message<DoubleConst> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleConst>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleConst";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleConst {
    return new DoubleConst().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleConst {
    return new DoubleConst().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleConst {
    return new DoubleConst().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleConst | PlainMessage<DoubleConst> | undefined,
    b: DoubleConst | PlainMessage<DoubleConst> | undefined
  ): boolean {
    return proto3.util.equals(DoubleConst, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleIn
 */
export class DoubleIn extends Message<DoubleIn> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleIn {
    return new DoubleIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleIn {
    return new DoubleIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleIn {
    return new DoubleIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleIn | PlainMessage<DoubleIn> | undefined,
    b: DoubleIn | PlainMessage<DoubleIn> | undefined
  ): boolean {
    return proto3.util.equals(DoubleIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleNotIn
 */
export class DoubleNotIn extends Message<DoubleNotIn> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleNotIn {
    return new DoubleNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleNotIn {
    return new DoubleNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleNotIn {
    return new DoubleNotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleNotIn | PlainMessage<DoubleNotIn> | undefined,
    b: DoubleNotIn | PlainMessage<DoubleNotIn> | undefined
  ): boolean {
    return proto3.util.equals(DoubleNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleLT
 */
export class DoubleLT extends Message<DoubleLT> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleLT {
    return new DoubleLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleLT {
    return new DoubleLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleLT {
    return new DoubleLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleLT | PlainMessage<DoubleLT> | undefined,
    b: DoubleLT | PlainMessage<DoubleLT> | undefined
  ): boolean {
    return proto3.util.equals(DoubleLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleLTE
 */
export class DoubleLTE extends Message<DoubleLTE> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleLTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleLTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleLTE {
    return new DoubleLTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleLTE {
    return new DoubleLTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleLTE {
    return new DoubleLTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleLTE | PlainMessage<DoubleLTE> | undefined,
    b: DoubleLTE | PlainMessage<DoubleLTE> | undefined
  ): boolean {
    return proto3.util.equals(DoubleLTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleGT
 */
export class DoubleGT extends Message<DoubleGT> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleGT {
    return new DoubleGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleGT {
    return new DoubleGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleGT {
    return new DoubleGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleGT | PlainMessage<DoubleGT> | undefined,
    b: DoubleGT | PlainMessage<DoubleGT> | undefined
  ): boolean {
    return proto3.util.equals(DoubleGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleGTE
 */
export class DoubleGTE extends Message<DoubleGTE> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleGTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleGTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleGTE {
    return new DoubleGTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleGTE {
    return new DoubleGTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleGTE {
    return new DoubleGTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleGTE | PlainMessage<DoubleGTE> | undefined,
    b: DoubleGTE | PlainMessage<DoubleGTE> | undefined
  ): boolean {
    return proto3.util.equals(DoubleGTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleGTLT
 */
export class DoubleGTLT extends Message<DoubleGTLT> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleGTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleGTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleGTLT {
    return new DoubleGTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleGTLT {
    return new DoubleGTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleGTLT {
    return new DoubleGTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleGTLT | PlainMessage<DoubleGTLT> | undefined,
    b: DoubleGTLT | PlainMessage<DoubleGTLT> | undefined
  ): boolean {
    return proto3.util.equals(DoubleGTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleExLTGT
 */
export class DoubleExLTGT extends Message<DoubleExLTGT> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleExLTGT {
    return new DoubleExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleExLTGT {
    return new DoubleExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleExLTGT {
    return new DoubleExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleExLTGT | PlainMessage<DoubleExLTGT> | undefined,
    b: DoubleExLTGT | PlainMessage<DoubleExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(DoubleExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleGTELTE
 */
export class DoubleGTELTE extends Message<DoubleGTELTE> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleGTELTE {
    return new DoubleGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleGTELTE {
    return new DoubleGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleGTELTE {
    return new DoubleGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleGTELTE | PlainMessage<DoubleGTELTE> | undefined,
    b: DoubleGTELTE | PlainMessage<DoubleGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(DoubleGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleExGTELTE
 */
export class DoubleExGTELTE extends Message<DoubleExGTELTE> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleExGTELTE {
    return new DoubleExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleExGTELTE {
    return new DoubleExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleExGTELTE {
    return new DoubleExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleExGTELTE | PlainMessage<DoubleExGTELTE> | undefined,
    b: DoubleExGTELTE | PlainMessage<DoubleExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(DoubleExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.DoubleIgnore
 */
export class DoubleIgnore extends Message<DoubleIgnore> {
  /**
   * @generated from field: double val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<DoubleIgnore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.DoubleIgnore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleIgnore {
    return new DoubleIgnore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleIgnore {
    return new DoubleIgnore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleIgnore {
    return new DoubleIgnore().fromJsonString(jsonString, options);
  }

  static equals(
    a: DoubleIgnore | PlainMessage<DoubleIgnore> | undefined,
    b: DoubleIgnore | PlainMessage<DoubleIgnore> | undefined
  ): boolean {
    return proto3.util.equals(DoubleIgnore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32None
 */
export class Int32None extends Message<Int32None> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32None {
    return new Int32None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32None {
    return new Int32None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32None {
    return new Int32None().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32None | PlainMessage<Int32None> | undefined,
    b: Int32None | PlainMessage<Int32None> | undefined
  ): boolean {
    return proto3.util.equals(Int32None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32Const
 */
export class Int32Const extends Message<Int32Const> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Const {
    return new Int32Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Const {
    return new Int32Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Const {
    return new Int32Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32Const | PlainMessage<Int32Const> | undefined,
    b: Int32Const | PlainMessage<Int32Const> | undefined
  ): boolean {
    return proto3.util.equals(Int32Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32In
 */
export class Int32In extends Message<Int32In> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32In {
    return new Int32In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32In {
    return new Int32In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32In {
    return new Int32In().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32In | PlainMessage<Int32In> | undefined,
    b: Int32In | PlainMessage<Int32In> | undefined
  ): boolean {
    return proto3.util.equals(Int32In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32NotIn
 */
export class Int32NotIn extends Message<Int32NotIn> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32NotIn {
    return new Int32NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32NotIn {
    return new Int32NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32NotIn {
    return new Int32NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32NotIn | PlainMessage<Int32NotIn> | undefined,
    b: Int32NotIn | PlainMessage<Int32NotIn> | undefined
  ): boolean {
    return proto3.util.equals(Int32NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32LT
 */
export class Int32LT extends Message<Int32LT> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32LT {
    return new Int32LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32LT {
    return new Int32LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32LT {
    return new Int32LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32LT | PlainMessage<Int32LT> | undefined,
    b: Int32LT | PlainMessage<Int32LT> | undefined
  ): boolean {
    return proto3.util.equals(Int32LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32LTE
 */
export class Int32LTE extends Message<Int32LTE> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32LTE {
    return new Int32LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32LTE {
    return new Int32LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32LTE {
    return new Int32LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32LTE | PlainMessage<Int32LTE> | undefined,
    b: Int32LTE | PlainMessage<Int32LTE> | undefined
  ): boolean {
    return proto3.util.equals(Int32LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32GT
 */
export class Int32GT extends Message<Int32GT> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32GT {
    return new Int32GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32GT {
    return new Int32GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32GT {
    return new Int32GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32GT | PlainMessage<Int32GT> | undefined,
    b: Int32GT | PlainMessage<Int32GT> | undefined
  ): boolean {
    return proto3.util.equals(Int32GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32GTE
 */
export class Int32GTE extends Message<Int32GTE> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32GTE {
    return new Int32GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32GTE {
    return new Int32GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32GTE {
    return new Int32GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32GTE | PlainMessage<Int32GTE> | undefined,
    b: Int32GTE | PlainMessage<Int32GTE> | undefined
  ): boolean {
    return proto3.util.equals(Int32GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32GTLT
 */
export class Int32GTLT extends Message<Int32GTLT> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32GTLT {
    return new Int32GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32GTLT {
    return new Int32GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32GTLT {
    return new Int32GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32GTLT | PlainMessage<Int32GTLT> | undefined,
    b: Int32GTLT | PlainMessage<Int32GTLT> | undefined
  ): boolean {
    return proto3.util.equals(Int32GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32ExLTGT
 */
export class Int32ExLTGT extends Message<Int32ExLTGT> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32ExLTGT {
    return new Int32ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32ExLTGT {
    return new Int32ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32ExLTGT {
    return new Int32ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32ExLTGT | PlainMessage<Int32ExLTGT> | undefined,
    b: Int32ExLTGT | PlainMessage<Int32ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(Int32ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32GTELTE
 */
export class Int32GTELTE extends Message<Int32GTELTE> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32GTELTE {
    return new Int32GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32GTELTE {
    return new Int32GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32GTELTE {
    return new Int32GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32GTELTE | PlainMessage<Int32GTELTE> | undefined,
    b: Int32GTELTE | PlainMessage<Int32GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Int32GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32ExGTELTE
 */
export class Int32ExGTELTE extends Message<Int32ExGTELTE> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32ExGTELTE {
    return new Int32ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32ExGTELTE {
    return new Int32ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32ExGTELTE {
    return new Int32ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32ExGTELTE | PlainMessage<Int32ExGTELTE> | undefined,
    b: Int32ExGTELTE | PlainMessage<Int32ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Int32ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int32Ignore
 */
export class Int32Ignore extends Message<Int32Ignore> {
  /**
   * @generated from field: int32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Int32Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int32Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Ignore {
    return new Int32Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Ignore {
    return new Int32Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Ignore {
    return new Int32Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int32Ignore | PlainMessage<Int32Ignore> | undefined,
    b: Int32Ignore | PlainMessage<Int32Ignore> | undefined
  ): boolean {
    return proto3.util.equals(Int32Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64None
 */
export class Int64None extends Message<Int64None> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64None {
    return new Int64None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64None {
    return new Int64None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64None {
    return new Int64None().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64None | PlainMessage<Int64None> | undefined,
    b: Int64None | PlainMessage<Int64None> | undefined
  ): boolean {
    return proto3.util.equals(Int64None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64Const
 */
export class Int64Const extends Message<Int64Const> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Const {
    return new Int64Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Const {
    return new Int64Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Const {
    return new Int64Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64Const | PlainMessage<Int64Const> | undefined,
    b: Int64Const | PlainMessage<Int64Const> | undefined
  ): boolean {
    return proto3.util.equals(Int64Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64In
 */
export class Int64In extends Message<Int64In> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64In {
    return new Int64In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64In {
    return new Int64In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64In {
    return new Int64In().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64In | PlainMessage<Int64In> | undefined,
    b: Int64In | PlainMessage<Int64In> | undefined
  ): boolean {
    return proto3.util.equals(Int64In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64NotIn
 */
export class Int64NotIn extends Message<Int64NotIn> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64NotIn {
    return new Int64NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64NotIn {
    return new Int64NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64NotIn {
    return new Int64NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64NotIn | PlainMessage<Int64NotIn> | undefined,
    b: Int64NotIn | PlainMessage<Int64NotIn> | undefined
  ): boolean {
    return proto3.util.equals(Int64NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64LT
 */
export class Int64LT extends Message<Int64LT> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64LT {
    return new Int64LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64LT {
    return new Int64LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64LT {
    return new Int64LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64LT | PlainMessage<Int64LT> | undefined,
    b: Int64LT | PlainMessage<Int64LT> | undefined
  ): boolean {
    return proto3.util.equals(Int64LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64LTE
 */
export class Int64LTE extends Message<Int64LTE> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64LTE {
    return new Int64LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64LTE {
    return new Int64LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64LTE {
    return new Int64LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64LTE | PlainMessage<Int64LTE> | undefined,
    b: Int64LTE | PlainMessage<Int64LTE> | undefined
  ): boolean {
    return proto3.util.equals(Int64LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64GT
 */
export class Int64GT extends Message<Int64GT> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64GT {
    return new Int64GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64GT {
    return new Int64GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64GT {
    return new Int64GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64GT | PlainMessage<Int64GT> | undefined,
    b: Int64GT | PlainMessage<Int64GT> | undefined
  ): boolean {
    return proto3.util.equals(Int64GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64GTE
 */
export class Int64GTE extends Message<Int64GTE> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64GTE {
    return new Int64GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64GTE {
    return new Int64GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64GTE {
    return new Int64GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64GTE | PlainMessage<Int64GTE> | undefined,
    b: Int64GTE | PlainMessage<Int64GTE> | undefined
  ): boolean {
    return proto3.util.equals(Int64GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64GTLT
 */
export class Int64GTLT extends Message<Int64GTLT> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64GTLT {
    return new Int64GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64GTLT {
    return new Int64GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64GTLT {
    return new Int64GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64GTLT | PlainMessage<Int64GTLT> | undefined,
    b: Int64GTLT | PlainMessage<Int64GTLT> | undefined
  ): boolean {
    return proto3.util.equals(Int64GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64ExLTGT
 */
export class Int64ExLTGT extends Message<Int64ExLTGT> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64ExLTGT {
    return new Int64ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64ExLTGT {
    return new Int64ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64ExLTGT {
    return new Int64ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64ExLTGT | PlainMessage<Int64ExLTGT> | undefined,
    b: Int64ExLTGT | PlainMessage<Int64ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(Int64ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64GTELTE
 */
export class Int64GTELTE extends Message<Int64GTELTE> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64GTELTE {
    return new Int64GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64GTELTE {
    return new Int64GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64GTELTE {
    return new Int64GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64GTELTE | PlainMessage<Int64GTELTE> | undefined,
    b: Int64GTELTE | PlainMessage<Int64GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Int64GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64ExGTELTE
 */
export class Int64ExGTELTE extends Message<Int64ExGTELTE> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64ExGTELTE {
    return new Int64ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64ExGTELTE {
    return new Int64ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64ExGTELTE {
    return new Int64ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64ExGTELTE | PlainMessage<Int64ExGTELTE> | undefined,
    b: Int64ExGTELTE | PlainMessage<Int64ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Int64ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64Ignore
 */
export class Int64Ignore extends Message<Int64Ignore> {
  /**
   * @generated from field: int64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Int64Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Ignore {
    return new Int64Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Ignore {
    return new Int64Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Ignore {
    return new Int64Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64Ignore | PlainMessage<Int64Ignore> | undefined,
    b: Int64Ignore | PlainMessage<Int64Ignore> | undefined
  ): boolean {
    return proto3.util.equals(Int64Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32None
 */
export class UInt32None extends Message<UInt32None> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32None {
    return new UInt32None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32None {
    return new UInt32None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32None {
    return new UInt32None().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32None | PlainMessage<UInt32None> | undefined,
    b: UInt32None | PlainMessage<UInt32None> | undefined
  ): boolean {
    return proto3.util.equals(UInt32None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32Const
 */
export class UInt32Const extends Message<UInt32Const> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Const {
    return new UInt32Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Const {
    return new UInt32Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Const {
    return new UInt32Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32Const | PlainMessage<UInt32Const> | undefined,
    b: UInt32Const | PlainMessage<UInt32Const> | undefined
  ): boolean {
    return proto3.util.equals(UInt32Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32In
 */
export class UInt32In extends Message<UInt32In> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32In {
    return new UInt32In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32In {
    return new UInt32In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32In {
    return new UInt32In().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32In | PlainMessage<UInt32In> | undefined,
    b: UInt32In | PlainMessage<UInt32In> | undefined
  ): boolean {
    return proto3.util.equals(UInt32In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32NotIn
 */
export class UInt32NotIn extends Message<UInt32NotIn> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32NotIn {
    return new UInt32NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32NotIn {
    return new UInt32NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32NotIn {
    return new UInt32NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32NotIn | PlainMessage<UInt32NotIn> | undefined,
    b: UInt32NotIn | PlainMessage<UInt32NotIn> | undefined
  ): boolean {
    return proto3.util.equals(UInt32NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32LT
 */
export class UInt32LT extends Message<UInt32LT> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32LT {
    return new UInt32LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32LT {
    return new UInt32LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32LT {
    return new UInt32LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32LT | PlainMessage<UInt32LT> | undefined,
    b: UInt32LT | PlainMessage<UInt32LT> | undefined
  ): boolean {
    return proto3.util.equals(UInt32LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32LTE
 */
export class UInt32LTE extends Message<UInt32LTE> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32LTE {
    return new UInt32LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32LTE {
    return new UInt32LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32LTE {
    return new UInt32LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32LTE | PlainMessage<UInt32LTE> | undefined,
    b: UInt32LTE | PlainMessage<UInt32LTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt32LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32GT
 */
export class UInt32GT extends Message<UInt32GT> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32GT {
    return new UInt32GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32GT {
    return new UInt32GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32GT {
    return new UInt32GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32GT | PlainMessage<UInt32GT> | undefined,
    b: UInt32GT | PlainMessage<UInt32GT> | undefined
  ): boolean {
    return proto3.util.equals(UInt32GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32GTE
 */
export class UInt32GTE extends Message<UInt32GTE> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32GTE {
    return new UInt32GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32GTE {
    return new UInt32GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32GTE {
    return new UInt32GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32GTE | PlainMessage<UInt32GTE> | undefined,
    b: UInt32GTE | PlainMessage<UInt32GTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt32GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32GTLT
 */
export class UInt32GTLT extends Message<UInt32GTLT> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32GTLT {
    return new UInt32GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32GTLT {
    return new UInt32GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32GTLT {
    return new UInt32GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32GTLT | PlainMessage<UInt32GTLT> | undefined,
    b: UInt32GTLT | PlainMessage<UInt32GTLT> | undefined
  ): boolean {
    return proto3.util.equals(UInt32GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32ExLTGT
 */
export class UInt32ExLTGT extends Message<UInt32ExLTGT> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32ExLTGT {
    return new UInt32ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32ExLTGT {
    return new UInt32ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32ExLTGT {
    return new UInt32ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32ExLTGT | PlainMessage<UInt32ExLTGT> | undefined,
    b: UInt32ExLTGT | PlainMessage<UInt32ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(UInt32ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32GTELTE
 */
export class UInt32GTELTE extends Message<UInt32GTELTE> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32GTELTE {
    return new UInt32GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32GTELTE {
    return new UInt32GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32GTELTE {
    return new UInt32GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32GTELTE | PlainMessage<UInt32GTELTE> | undefined,
    b: UInt32GTELTE | PlainMessage<UInt32GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt32GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32ExGTELTE
 */
export class UInt32ExGTELTE extends Message<UInt32ExGTELTE> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32ExGTELTE {
    return new UInt32ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32ExGTELTE {
    return new UInt32ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32ExGTELTE {
    return new UInt32ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32ExGTELTE | PlainMessage<UInt32ExGTELTE> | undefined,
    b: UInt32ExGTELTE | PlainMessage<UInt32ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt32ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt32Ignore
 */
export class UInt32Ignore extends Message<UInt32Ignore> {
  /**
   * @generated from field: uint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<UInt32Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt32Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Ignore {
    return new UInt32Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Ignore {
    return new UInt32Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Ignore {
    return new UInt32Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt32Ignore | PlainMessage<UInt32Ignore> | undefined,
    b: UInt32Ignore | PlainMessage<UInt32Ignore> | undefined
  ): boolean {
    return proto3.util.equals(UInt32Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64None
 */
export class UInt64None extends Message<UInt64None> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64None {
    return new UInt64None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64None {
    return new UInt64None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64None {
    return new UInt64None().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64None | PlainMessage<UInt64None> | undefined,
    b: UInt64None | PlainMessage<UInt64None> | undefined
  ): boolean {
    return proto3.util.equals(UInt64None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64Const
 */
export class UInt64Const extends Message<UInt64Const> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64Const {
    return new UInt64Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64Const {
    return new UInt64Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64Const {
    return new UInt64Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64Const | PlainMessage<UInt64Const> | undefined,
    b: UInt64Const | PlainMessage<UInt64Const> | undefined
  ): boolean {
    return proto3.util.equals(UInt64Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64In
 */
export class UInt64In extends Message<UInt64In> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64In {
    return new UInt64In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64In {
    return new UInt64In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64In {
    return new UInt64In().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64In | PlainMessage<UInt64In> | undefined,
    b: UInt64In | PlainMessage<UInt64In> | undefined
  ): boolean {
    return proto3.util.equals(UInt64In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64NotIn
 */
export class UInt64NotIn extends Message<UInt64NotIn> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64NotIn {
    return new UInt64NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64NotIn {
    return new UInt64NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64NotIn {
    return new UInt64NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64NotIn | PlainMessage<UInt64NotIn> | undefined,
    b: UInt64NotIn | PlainMessage<UInt64NotIn> | undefined
  ): boolean {
    return proto3.util.equals(UInt64NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64LT
 */
export class UInt64LT extends Message<UInt64LT> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64LT {
    return new UInt64LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64LT {
    return new UInt64LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64LT {
    return new UInt64LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64LT | PlainMessage<UInt64LT> | undefined,
    b: UInt64LT | PlainMessage<UInt64LT> | undefined
  ): boolean {
    return proto3.util.equals(UInt64LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64LTE
 */
export class UInt64LTE extends Message<UInt64LTE> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64LTE {
    return new UInt64LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64LTE {
    return new UInt64LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64LTE {
    return new UInt64LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64LTE | PlainMessage<UInt64LTE> | undefined,
    b: UInt64LTE | PlainMessage<UInt64LTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt64LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64GT
 */
export class UInt64GT extends Message<UInt64GT> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64GT {
    return new UInt64GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64GT {
    return new UInt64GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64GT {
    return new UInt64GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64GT | PlainMessage<UInt64GT> | undefined,
    b: UInt64GT | PlainMessage<UInt64GT> | undefined
  ): boolean {
    return proto3.util.equals(UInt64GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64GTE
 */
export class UInt64GTE extends Message<UInt64GTE> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64GTE {
    return new UInt64GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64GTE {
    return new UInt64GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64GTE {
    return new UInt64GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64GTE | PlainMessage<UInt64GTE> | undefined,
    b: UInt64GTE | PlainMessage<UInt64GTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt64GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64GTLT
 */
export class UInt64GTLT extends Message<UInt64GTLT> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64GTLT {
    return new UInt64GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64GTLT {
    return new UInt64GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64GTLT {
    return new UInt64GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64GTLT | PlainMessage<UInt64GTLT> | undefined,
    b: UInt64GTLT | PlainMessage<UInt64GTLT> | undefined
  ): boolean {
    return proto3.util.equals(UInt64GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64ExLTGT
 */
export class UInt64ExLTGT extends Message<UInt64ExLTGT> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64ExLTGT {
    return new UInt64ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64ExLTGT {
    return new UInt64ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64ExLTGT {
    return new UInt64ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64ExLTGT | PlainMessage<UInt64ExLTGT> | undefined,
    b: UInt64ExLTGT | PlainMessage<UInt64ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(UInt64ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64GTELTE
 */
export class UInt64GTELTE extends Message<UInt64GTELTE> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64GTELTE {
    return new UInt64GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64GTELTE {
    return new UInt64GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64GTELTE {
    return new UInt64GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64GTELTE | PlainMessage<UInt64GTELTE> | undefined,
    b: UInt64GTELTE | PlainMessage<UInt64GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt64GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64ExGTELTE
 */
export class UInt64ExGTELTE extends Message<UInt64ExGTELTE> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64ExGTELTE {
    return new UInt64ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64ExGTELTE {
    return new UInt64ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64ExGTELTE {
    return new UInt64ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64ExGTELTE | PlainMessage<UInt64ExGTELTE> | undefined,
    b: UInt64ExGTELTE | PlainMessage<UInt64ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(UInt64ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.UInt64Ignore
 */
export class UInt64Ignore extends Message<UInt64Ignore> {
  /**
   * @generated from field: uint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<UInt64Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.UInt64Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64Ignore {
    return new UInt64Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64Ignore {
    return new UInt64Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64Ignore {
    return new UInt64Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: UInt64Ignore | PlainMessage<UInt64Ignore> | undefined,
    b: UInt64Ignore | PlainMessage<UInt64Ignore> | undefined
  ): boolean {
    return proto3.util.equals(UInt64Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32None
 */
export class SInt32None extends Message<SInt32None> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32None {
    return new SInt32None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32None {
    return new SInt32None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32None {
    return new SInt32None().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32None | PlainMessage<SInt32None> | undefined,
    b: SInt32None | PlainMessage<SInt32None> | undefined
  ): boolean {
    return proto3.util.equals(SInt32None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32Const
 */
export class SInt32Const extends Message<SInt32Const> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32Const {
    return new SInt32Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32Const {
    return new SInt32Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32Const {
    return new SInt32Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32Const | PlainMessage<SInt32Const> | undefined,
    b: SInt32Const | PlainMessage<SInt32Const> | undefined
  ): boolean {
    return proto3.util.equals(SInt32Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32In
 */
export class SInt32In extends Message<SInt32In> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32In {
    return new SInt32In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32In {
    return new SInt32In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32In {
    return new SInt32In().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32In | PlainMessage<SInt32In> | undefined,
    b: SInt32In | PlainMessage<SInt32In> | undefined
  ): boolean {
    return proto3.util.equals(SInt32In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32NotIn
 */
export class SInt32NotIn extends Message<SInt32NotIn> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32NotIn {
    return new SInt32NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32NotIn {
    return new SInt32NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32NotIn {
    return new SInt32NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32NotIn | PlainMessage<SInt32NotIn> | undefined,
    b: SInt32NotIn | PlainMessage<SInt32NotIn> | undefined
  ): boolean {
    return proto3.util.equals(SInt32NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32LT
 */
export class SInt32LT extends Message<SInt32LT> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32LT {
    return new SInt32LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32LT {
    return new SInt32LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32LT {
    return new SInt32LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32LT | PlainMessage<SInt32LT> | undefined,
    b: SInt32LT | PlainMessage<SInt32LT> | undefined
  ): boolean {
    return proto3.util.equals(SInt32LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32LTE
 */
export class SInt32LTE extends Message<SInt32LTE> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32LTE {
    return new SInt32LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32LTE {
    return new SInt32LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32LTE {
    return new SInt32LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32LTE | PlainMessage<SInt32LTE> | undefined,
    b: SInt32LTE | PlainMessage<SInt32LTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt32LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32GT
 */
export class SInt32GT extends Message<SInt32GT> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32GT {
    return new SInt32GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32GT {
    return new SInt32GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32GT {
    return new SInt32GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32GT | PlainMessage<SInt32GT> | undefined,
    b: SInt32GT | PlainMessage<SInt32GT> | undefined
  ): boolean {
    return proto3.util.equals(SInt32GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32GTE
 */
export class SInt32GTE extends Message<SInt32GTE> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32GTE {
    return new SInt32GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32GTE {
    return new SInt32GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32GTE {
    return new SInt32GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32GTE | PlainMessage<SInt32GTE> | undefined,
    b: SInt32GTE | PlainMessage<SInt32GTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt32GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32GTLT
 */
export class SInt32GTLT extends Message<SInt32GTLT> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32GTLT {
    return new SInt32GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32GTLT {
    return new SInt32GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32GTLT {
    return new SInt32GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32GTLT | PlainMessage<SInt32GTLT> | undefined,
    b: SInt32GTLT | PlainMessage<SInt32GTLT> | undefined
  ): boolean {
    return proto3.util.equals(SInt32GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32ExLTGT
 */
export class SInt32ExLTGT extends Message<SInt32ExLTGT> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32ExLTGT {
    return new SInt32ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32ExLTGT {
    return new SInt32ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32ExLTGT {
    return new SInt32ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32ExLTGT | PlainMessage<SInt32ExLTGT> | undefined,
    b: SInt32ExLTGT | PlainMessage<SInt32ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(SInt32ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32GTELTE
 */
export class SInt32GTELTE extends Message<SInt32GTELTE> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32GTELTE {
    return new SInt32GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32GTELTE {
    return new SInt32GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32GTELTE {
    return new SInt32GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32GTELTE | PlainMessage<SInt32GTELTE> | undefined,
    b: SInt32GTELTE | PlainMessage<SInt32GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt32GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32ExGTELTE
 */
export class SInt32ExGTELTE extends Message<SInt32ExGTELTE> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32ExGTELTE {
    return new SInt32ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32ExGTELTE {
    return new SInt32ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32ExGTELTE {
    return new SInt32ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32ExGTELTE | PlainMessage<SInt32ExGTELTE> | undefined,
    b: SInt32ExGTELTE | PlainMessage<SInt32ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt32ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt32Ignore
 */
export class SInt32Ignore extends Message<SInt32Ignore> {
  /**
   * @generated from field: sint32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SInt32Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt32Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32Ignore {
    return new SInt32Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32Ignore {
    return new SInt32Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32Ignore {
    return new SInt32Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt32Ignore | PlainMessage<SInt32Ignore> | undefined,
    b: SInt32Ignore | PlainMessage<SInt32Ignore> | undefined
  ): boolean {
    return proto3.util.equals(SInt32Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64None
 */
export class SInt64None extends Message<SInt64None> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64None {
    return new SInt64None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64None {
    return new SInt64None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64None {
    return new SInt64None().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64None | PlainMessage<SInt64None> | undefined,
    b: SInt64None | PlainMessage<SInt64None> | undefined
  ): boolean {
    return proto3.util.equals(SInt64None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64Const
 */
export class SInt64Const extends Message<SInt64Const> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64Const {
    return new SInt64Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64Const {
    return new SInt64Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64Const {
    return new SInt64Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64Const | PlainMessage<SInt64Const> | undefined,
    b: SInt64Const | PlainMessage<SInt64Const> | undefined
  ): boolean {
    return proto3.util.equals(SInt64Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64In
 */
export class SInt64In extends Message<SInt64In> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64In {
    return new SInt64In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64In {
    return new SInt64In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64In {
    return new SInt64In().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64In | PlainMessage<SInt64In> | undefined,
    b: SInt64In | PlainMessage<SInt64In> | undefined
  ): boolean {
    return proto3.util.equals(SInt64In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64NotIn
 */
export class SInt64NotIn extends Message<SInt64NotIn> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64NotIn {
    return new SInt64NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64NotIn {
    return new SInt64NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64NotIn {
    return new SInt64NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64NotIn | PlainMessage<SInt64NotIn> | undefined,
    b: SInt64NotIn | PlainMessage<SInt64NotIn> | undefined
  ): boolean {
    return proto3.util.equals(SInt64NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64LT
 */
export class SInt64LT extends Message<SInt64LT> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64LT {
    return new SInt64LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64LT {
    return new SInt64LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64LT {
    return new SInt64LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64LT | PlainMessage<SInt64LT> | undefined,
    b: SInt64LT | PlainMessage<SInt64LT> | undefined
  ): boolean {
    return proto3.util.equals(SInt64LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64LTE
 */
export class SInt64LTE extends Message<SInt64LTE> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64LTE {
    return new SInt64LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64LTE {
    return new SInt64LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64LTE {
    return new SInt64LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64LTE | PlainMessage<SInt64LTE> | undefined,
    b: SInt64LTE | PlainMessage<SInt64LTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt64LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64GT
 */
export class SInt64GT extends Message<SInt64GT> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64GT {
    return new SInt64GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64GT {
    return new SInt64GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64GT {
    return new SInt64GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64GT | PlainMessage<SInt64GT> | undefined,
    b: SInt64GT | PlainMessage<SInt64GT> | undefined
  ): boolean {
    return proto3.util.equals(SInt64GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64GTE
 */
export class SInt64GTE extends Message<SInt64GTE> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64GTE {
    return new SInt64GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64GTE {
    return new SInt64GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64GTE {
    return new SInt64GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64GTE | PlainMessage<SInt64GTE> | undefined,
    b: SInt64GTE | PlainMessage<SInt64GTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt64GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64GTLT
 */
export class SInt64GTLT extends Message<SInt64GTLT> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64GTLT {
    return new SInt64GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64GTLT {
    return new SInt64GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64GTLT {
    return new SInt64GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64GTLT | PlainMessage<SInt64GTLT> | undefined,
    b: SInt64GTLT | PlainMessage<SInt64GTLT> | undefined
  ): boolean {
    return proto3.util.equals(SInt64GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64ExLTGT
 */
export class SInt64ExLTGT extends Message<SInt64ExLTGT> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64ExLTGT {
    return new SInt64ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64ExLTGT {
    return new SInt64ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64ExLTGT {
    return new SInt64ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64ExLTGT | PlainMessage<SInt64ExLTGT> | undefined,
    b: SInt64ExLTGT | PlainMessage<SInt64ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(SInt64ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64GTELTE
 */
export class SInt64GTELTE extends Message<SInt64GTELTE> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64GTELTE {
    return new SInt64GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64GTELTE {
    return new SInt64GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64GTELTE {
    return new SInt64GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64GTELTE | PlainMessage<SInt64GTELTE> | undefined,
    b: SInt64GTELTE | PlainMessage<SInt64GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt64GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64ExGTELTE
 */
export class SInt64ExGTELTE extends Message<SInt64ExGTELTE> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64ExGTELTE {
    return new SInt64ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64ExGTELTE {
    return new SInt64ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64ExGTELTE {
    return new SInt64ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64ExGTELTE | PlainMessage<SInt64ExGTELTE> | undefined,
    b: SInt64ExGTELTE | PlainMessage<SInt64ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SInt64ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SInt64Ignore
 */
export class SInt64Ignore extends Message<SInt64Ignore> {
  /**
   * @generated from field: sint64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SInt64Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64Ignore {
    return new SInt64Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64Ignore {
    return new SInt64Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64Ignore {
    return new SInt64Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: SInt64Ignore | PlainMessage<SInt64Ignore> | undefined,
    b: SInt64Ignore | PlainMessage<SInt64Ignore> | undefined
  ): boolean {
    return proto3.util.equals(SInt64Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32None
 */
export class Fixed32None extends Message<Fixed32None> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32None {
    return new Fixed32None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32None {
    return new Fixed32None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32None {
    return new Fixed32None().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32None | PlainMessage<Fixed32None> | undefined,
    b: Fixed32None | PlainMessage<Fixed32None> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32Const
 */
export class Fixed32Const extends Message<Fixed32Const> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32Const {
    return new Fixed32Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32Const {
    return new Fixed32Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32Const {
    return new Fixed32Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32Const | PlainMessage<Fixed32Const> | undefined,
    b: Fixed32Const | PlainMessage<Fixed32Const> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32In
 */
export class Fixed32In extends Message<Fixed32In> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32In {
    return new Fixed32In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32In {
    return new Fixed32In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32In {
    return new Fixed32In().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32In | PlainMessage<Fixed32In> | undefined,
    b: Fixed32In | PlainMessage<Fixed32In> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32NotIn
 */
export class Fixed32NotIn extends Message<Fixed32NotIn> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32NotIn {
    return new Fixed32NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32NotIn {
    return new Fixed32NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32NotIn {
    return new Fixed32NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32NotIn | PlainMessage<Fixed32NotIn> | undefined,
    b: Fixed32NotIn | PlainMessage<Fixed32NotIn> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32LT
 */
export class Fixed32LT extends Message<Fixed32LT> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32LT {
    return new Fixed32LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32LT {
    return new Fixed32LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32LT {
    return new Fixed32LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32LT | PlainMessage<Fixed32LT> | undefined,
    b: Fixed32LT | PlainMessage<Fixed32LT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32LTE
 */
export class Fixed32LTE extends Message<Fixed32LTE> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32LTE {
    return new Fixed32LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32LTE {
    return new Fixed32LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32LTE {
    return new Fixed32LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32LTE | PlainMessage<Fixed32LTE> | undefined,
    b: Fixed32LTE | PlainMessage<Fixed32LTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32GT
 */
export class Fixed32GT extends Message<Fixed32GT> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32GT {
    return new Fixed32GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32GT {
    return new Fixed32GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32GT {
    return new Fixed32GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32GT | PlainMessage<Fixed32GT> | undefined,
    b: Fixed32GT | PlainMessage<Fixed32GT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32GTE
 */
export class Fixed32GTE extends Message<Fixed32GTE> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32GTE {
    return new Fixed32GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32GTE {
    return new Fixed32GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32GTE {
    return new Fixed32GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32GTE | PlainMessage<Fixed32GTE> | undefined,
    b: Fixed32GTE | PlainMessage<Fixed32GTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32GTLT
 */
export class Fixed32GTLT extends Message<Fixed32GTLT> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32GTLT {
    return new Fixed32GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32GTLT {
    return new Fixed32GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32GTLT {
    return new Fixed32GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32GTLT | PlainMessage<Fixed32GTLT> | undefined,
    b: Fixed32GTLT | PlainMessage<Fixed32GTLT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32ExLTGT
 */
export class Fixed32ExLTGT extends Message<Fixed32ExLTGT> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32ExLTGT {
    return new Fixed32ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32ExLTGT {
    return new Fixed32ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32ExLTGT {
    return new Fixed32ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32ExLTGT | PlainMessage<Fixed32ExLTGT> | undefined,
    b: Fixed32ExLTGT | PlainMessage<Fixed32ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32GTELTE
 */
export class Fixed32GTELTE extends Message<Fixed32GTELTE> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32GTELTE {
    return new Fixed32GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32GTELTE {
    return new Fixed32GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32GTELTE {
    return new Fixed32GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32GTELTE | PlainMessage<Fixed32GTELTE> | undefined,
    b: Fixed32GTELTE | PlainMessage<Fixed32GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32ExGTELTE
 */
export class Fixed32ExGTELTE extends Message<Fixed32ExGTELTE> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32ExGTELTE {
    return new Fixed32ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32ExGTELTE {
    return new Fixed32ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32ExGTELTE {
    return new Fixed32ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32ExGTELTE | PlainMessage<Fixed32ExGTELTE> | undefined,
    b: Fixed32ExGTELTE | PlainMessage<Fixed32ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed32Ignore
 */
export class Fixed32Ignore extends Message<Fixed32Ignore> {
  /**
   * @generated from field: fixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<Fixed32Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed32Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32Ignore {
    return new Fixed32Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32Ignore {
    return new Fixed32Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32Ignore {
    return new Fixed32Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed32Ignore | PlainMessage<Fixed32Ignore> | undefined,
    b: Fixed32Ignore | PlainMessage<Fixed32Ignore> | undefined
  ): boolean {
    return proto3.util.equals(Fixed32Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64None
 */
export class Fixed64None extends Message<Fixed64None> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64None {
    return new Fixed64None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64None {
    return new Fixed64None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64None {
    return new Fixed64None().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64None | PlainMessage<Fixed64None> | undefined,
    b: Fixed64None | PlainMessage<Fixed64None> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64Const
 */
export class Fixed64Const extends Message<Fixed64Const> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64Const {
    return new Fixed64Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64Const {
    return new Fixed64Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64Const {
    return new Fixed64Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64Const | PlainMessage<Fixed64Const> | undefined,
    b: Fixed64Const | PlainMessage<Fixed64Const> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64In
 */
export class Fixed64In extends Message<Fixed64In> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64In {
    return new Fixed64In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64In {
    return new Fixed64In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64In {
    return new Fixed64In().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64In | PlainMessage<Fixed64In> | undefined,
    b: Fixed64In | PlainMessage<Fixed64In> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64NotIn
 */
export class Fixed64NotIn extends Message<Fixed64NotIn> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64NotIn {
    return new Fixed64NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64NotIn {
    return new Fixed64NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64NotIn {
    return new Fixed64NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64NotIn | PlainMessage<Fixed64NotIn> | undefined,
    b: Fixed64NotIn | PlainMessage<Fixed64NotIn> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64LT
 */
export class Fixed64LT extends Message<Fixed64LT> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64LT {
    return new Fixed64LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64LT {
    return new Fixed64LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64LT {
    return new Fixed64LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64LT | PlainMessage<Fixed64LT> | undefined,
    b: Fixed64LT | PlainMessage<Fixed64LT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64LTE
 */
export class Fixed64LTE extends Message<Fixed64LTE> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64LTE {
    return new Fixed64LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64LTE {
    return new Fixed64LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64LTE {
    return new Fixed64LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64LTE | PlainMessage<Fixed64LTE> | undefined,
    b: Fixed64LTE | PlainMessage<Fixed64LTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64GT
 */
export class Fixed64GT extends Message<Fixed64GT> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64GT {
    return new Fixed64GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64GT {
    return new Fixed64GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64GT {
    return new Fixed64GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64GT | PlainMessage<Fixed64GT> | undefined,
    b: Fixed64GT | PlainMessage<Fixed64GT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64GTE
 */
export class Fixed64GTE extends Message<Fixed64GTE> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64GTE {
    return new Fixed64GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64GTE {
    return new Fixed64GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64GTE {
    return new Fixed64GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64GTE | PlainMessage<Fixed64GTE> | undefined,
    b: Fixed64GTE | PlainMessage<Fixed64GTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64GTLT
 */
export class Fixed64GTLT extends Message<Fixed64GTLT> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64GTLT {
    return new Fixed64GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64GTLT {
    return new Fixed64GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64GTLT {
    return new Fixed64GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64GTLT | PlainMessage<Fixed64GTLT> | undefined,
    b: Fixed64GTLT | PlainMessage<Fixed64GTLT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64ExLTGT
 */
export class Fixed64ExLTGT extends Message<Fixed64ExLTGT> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64ExLTGT {
    return new Fixed64ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64ExLTGT {
    return new Fixed64ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64ExLTGT {
    return new Fixed64ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64ExLTGT | PlainMessage<Fixed64ExLTGT> | undefined,
    b: Fixed64ExLTGT | PlainMessage<Fixed64ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64GTELTE
 */
export class Fixed64GTELTE extends Message<Fixed64GTELTE> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64GTELTE {
    return new Fixed64GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64GTELTE {
    return new Fixed64GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64GTELTE {
    return new Fixed64GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64GTELTE | PlainMessage<Fixed64GTELTE> | undefined,
    b: Fixed64GTELTE | PlainMessage<Fixed64GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64ExGTELTE
 */
export class Fixed64ExGTELTE extends Message<Fixed64ExGTELTE> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64ExGTELTE {
    return new Fixed64ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64ExGTELTE {
    return new Fixed64ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64ExGTELTE {
    return new Fixed64ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64ExGTELTE | PlainMessage<Fixed64ExGTELTE> | undefined,
    b: Fixed64ExGTELTE | PlainMessage<Fixed64ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Fixed64Ignore
 */
export class Fixed64Ignore extends Message<Fixed64Ignore> {
  /**
   * @generated from field: fixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<Fixed64Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Fixed64Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64Ignore {
    return new Fixed64Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64Ignore {
    return new Fixed64Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64Ignore {
    return new Fixed64Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: Fixed64Ignore | PlainMessage<Fixed64Ignore> | undefined,
    b: Fixed64Ignore | PlainMessage<Fixed64Ignore> | undefined
  ): boolean {
    return proto3.util.equals(Fixed64Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32None
 */
export class SFixed32None extends Message<SFixed32None> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32None {
    return new SFixed32None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32None {
    return new SFixed32None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32None {
    return new SFixed32None().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32None | PlainMessage<SFixed32None> | undefined,
    b: SFixed32None | PlainMessage<SFixed32None> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32Const
 */
export class SFixed32Const extends Message<SFixed32Const> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32Const {
    return new SFixed32Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32Const {
    return new SFixed32Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32Const {
    return new SFixed32Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32Const | PlainMessage<SFixed32Const> | undefined,
    b: SFixed32Const | PlainMessage<SFixed32Const> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32In
 */
export class SFixed32In extends Message<SFixed32In> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32In {
    return new SFixed32In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32In {
    return new SFixed32In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32In {
    return new SFixed32In().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32In | PlainMessage<SFixed32In> | undefined,
    b: SFixed32In | PlainMessage<SFixed32In> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32NotIn
 */
export class SFixed32NotIn extends Message<SFixed32NotIn> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32NotIn {
    return new SFixed32NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32NotIn {
    return new SFixed32NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32NotIn {
    return new SFixed32NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32NotIn | PlainMessage<SFixed32NotIn> | undefined,
    b: SFixed32NotIn | PlainMessage<SFixed32NotIn> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32LT
 */
export class SFixed32LT extends Message<SFixed32LT> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32LT {
    return new SFixed32LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32LT {
    return new SFixed32LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32LT {
    return new SFixed32LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32LT | PlainMessage<SFixed32LT> | undefined,
    b: SFixed32LT | PlainMessage<SFixed32LT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32LTE
 */
export class SFixed32LTE extends Message<SFixed32LTE> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32LTE {
    return new SFixed32LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32LTE {
    return new SFixed32LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32LTE {
    return new SFixed32LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32LTE | PlainMessage<SFixed32LTE> | undefined,
    b: SFixed32LTE | PlainMessage<SFixed32LTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32GT
 */
export class SFixed32GT extends Message<SFixed32GT> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32GT {
    return new SFixed32GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32GT {
    return new SFixed32GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32GT {
    return new SFixed32GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32GT | PlainMessage<SFixed32GT> | undefined,
    b: SFixed32GT | PlainMessage<SFixed32GT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32GTE
 */
export class SFixed32GTE extends Message<SFixed32GTE> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32GTE {
    return new SFixed32GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32GTE {
    return new SFixed32GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32GTE {
    return new SFixed32GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32GTE | PlainMessage<SFixed32GTE> | undefined,
    b: SFixed32GTE | PlainMessage<SFixed32GTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32GTLT
 */
export class SFixed32GTLT extends Message<SFixed32GTLT> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32GTLT {
    return new SFixed32GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32GTLT {
    return new SFixed32GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32GTLT {
    return new SFixed32GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32GTLT | PlainMessage<SFixed32GTLT> | undefined,
    b: SFixed32GTLT | PlainMessage<SFixed32GTLT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32ExLTGT
 */
export class SFixed32ExLTGT extends Message<SFixed32ExLTGT> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32ExLTGT {
    return new SFixed32ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32ExLTGT {
    return new SFixed32ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32ExLTGT {
    return new SFixed32ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32ExLTGT | PlainMessage<SFixed32ExLTGT> | undefined,
    b: SFixed32ExLTGT | PlainMessage<SFixed32ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32GTELTE
 */
export class SFixed32GTELTE extends Message<SFixed32GTELTE> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32GTELTE {
    return new SFixed32GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32GTELTE {
    return new SFixed32GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32GTELTE {
    return new SFixed32GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32GTELTE | PlainMessage<SFixed32GTELTE> | undefined,
    b: SFixed32GTELTE | PlainMessage<SFixed32GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32ExGTELTE
 */
export class SFixed32ExGTELTE extends Message<SFixed32ExGTELTE> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32ExGTELTE {
    return new SFixed32ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32ExGTELTE {
    return new SFixed32ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32ExGTELTE {
    return new SFixed32ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32ExGTELTE | PlainMessage<SFixed32ExGTELTE> | undefined,
    b: SFixed32ExGTELTE | PlainMessage<SFixed32ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed32Ignore
 */
export class SFixed32Ignore extends Message<SFixed32Ignore> {
  /**
   * @generated from field: sfixed32 val = 1;
   */
  val = 0;

  constructor(data?: PartialMessage<SFixed32Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed32Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32Ignore {
    return new SFixed32Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32Ignore {
    return new SFixed32Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32Ignore {
    return new SFixed32Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed32Ignore | PlainMessage<SFixed32Ignore> | undefined,
    b: SFixed32Ignore | PlainMessage<SFixed32Ignore> | undefined
  ): boolean {
    return proto3.util.equals(SFixed32Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64None
 */
export class SFixed64None extends Message<SFixed64None> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64None>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64None";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64None {
    return new SFixed64None().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64None {
    return new SFixed64None().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64None {
    return new SFixed64None().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64None | PlainMessage<SFixed64None> | undefined,
    b: SFixed64None | PlainMessage<SFixed64None> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64None, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64Const
 */
export class SFixed64Const extends Message<SFixed64Const> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64Const>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64Const";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64Const {
    return new SFixed64Const().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64Const {
    return new SFixed64Const().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64Const {
    return new SFixed64Const().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64Const | PlainMessage<SFixed64Const> | undefined,
    b: SFixed64Const | PlainMessage<SFixed64Const> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64Const, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64In
 */
export class SFixed64In extends Message<SFixed64In> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64In {
    return new SFixed64In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64In {
    return new SFixed64In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64In {
    return new SFixed64In().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64In | PlainMessage<SFixed64In> | undefined,
    b: SFixed64In | PlainMessage<SFixed64In> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64In, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64NotIn
 */
export class SFixed64NotIn extends Message<SFixed64NotIn> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64NotIn {
    return new SFixed64NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64NotIn {
    return new SFixed64NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64NotIn {
    return new SFixed64NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64NotIn | PlainMessage<SFixed64NotIn> | undefined,
    b: SFixed64NotIn | PlainMessage<SFixed64NotIn> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64NotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64LT
 */
export class SFixed64LT extends Message<SFixed64LT> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64LT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64LT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64LT {
    return new SFixed64LT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64LT {
    return new SFixed64LT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64LT {
    return new SFixed64LT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64LT | PlainMessage<SFixed64LT> | undefined,
    b: SFixed64LT | PlainMessage<SFixed64LT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64LT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64LTE
 */
export class SFixed64LTE extends Message<SFixed64LTE> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64LTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64LTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64LTE {
    return new SFixed64LTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64LTE {
    return new SFixed64LTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64LTE {
    return new SFixed64LTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64LTE | PlainMessage<SFixed64LTE> | undefined,
    b: SFixed64LTE | PlainMessage<SFixed64LTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64LTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64GT
 */
export class SFixed64GT extends Message<SFixed64GT> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64GT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64GT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64GT {
    return new SFixed64GT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64GT {
    return new SFixed64GT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64GT {
    return new SFixed64GT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64GT | PlainMessage<SFixed64GT> | undefined,
    b: SFixed64GT | PlainMessage<SFixed64GT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64GT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64GTE
 */
export class SFixed64GTE extends Message<SFixed64GTE> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64GTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64GTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64GTE {
    return new SFixed64GTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64GTE {
    return new SFixed64GTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64GTE {
    return new SFixed64GTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64GTE | PlainMessage<SFixed64GTE> | undefined,
    b: SFixed64GTE | PlainMessage<SFixed64GTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64GTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64GTLT
 */
export class SFixed64GTLT extends Message<SFixed64GTLT> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64GTLT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64GTLT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64GTLT {
    return new SFixed64GTLT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64GTLT {
    return new SFixed64GTLT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64GTLT {
    return new SFixed64GTLT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64GTLT | PlainMessage<SFixed64GTLT> | undefined,
    b: SFixed64GTLT | PlainMessage<SFixed64GTLT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64GTLT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64ExLTGT
 */
export class SFixed64ExLTGT extends Message<SFixed64ExLTGT> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64ExLTGT>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64ExLTGT";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64ExLTGT {
    return new SFixed64ExLTGT().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64ExLTGT {
    return new SFixed64ExLTGT().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64ExLTGT {
    return new SFixed64ExLTGT().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64ExLTGT | PlainMessage<SFixed64ExLTGT> | undefined,
    b: SFixed64ExLTGT | PlainMessage<SFixed64ExLTGT> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64ExLTGT, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64GTELTE
 */
export class SFixed64GTELTE extends Message<SFixed64GTELTE> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64GTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64GTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64GTELTE {
    return new SFixed64GTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64GTELTE {
    return new SFixed64GTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64GTELTE {
    return new SFixed64GTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64GTELTE | PlainMessage<SFixed64GTELTE> | undefined,
    b: SFixed64GTELTE | PlainMessage<SFixed64GTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64GTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64ExGTELTE
 */
export class SFixed64ExGTELTE extends Message<SFixed64ExGTELTE> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64ExGTELTE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64ExGTELTE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64ExGTELTE {
    return new SFixed64ExGTELTE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64ExGTELTE {
    return new SFixed64ExGTELTE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64ExGTELTE {
    return new SFixed64ExGTELTE().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64ExGTELTE | PlainMessage<SFixed64ExGTELTE> | undefined,
    b: SFixed64ExGTELTE | PlainMessage<SFixed64ExGTELTE> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64ExGTELTE, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.SFixed64Ignore
 */
export class SFixed64Ignore extends Message<SFixed64Ignore> {
  /**
   * @generated from field: sfixed64 val = 1;
   */
  val = protoInt64.zero;

  constructor(data?: PartialMessage<SFixed64Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.SFixed64Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64Ignore {
    return new SFixed64Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64Ignore {
    return new SFixed64Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64Ignore {
    return new SFixed64Ignore().fromJsonString(jsonString, options);
  }

  static equals(
    a: SFixed64Ignore | PlainMessage<SFixed64Ignore> | undefined,
    b: SFixed64Ignore | PlainMessage<SFixed64Ignore> | undefined
  ): boolean {
    return proto3.util.equals(SFixed64Ignore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.Int64LTEOptional
 */
export class Int64LTEOptional extends Message<Int64LTEOptional> {
  /**
   * @generated from field: optional int64 val = 1;
   */
  val?: bigint;

  constructor(data?: PartialMessage<Int64LTEOptional>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.Int64LTEOptional";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64LTEOptional {
    return new Int64LTEOptional().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64LTEOptional {
    return new Int64LTEOptional().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64LTEOptional {
    return new Int64LTEOptional().fromJsonString(jsonString, options);
  }

  static equals(
    a: Int64LTEOptional | PlainMessage<Int64LTEOptional> | undefined,
    b: Int64LTEOptional | PlainMessage<Int64LTEOptional> | undefined
  ): boolean {
    return proto3.util.equals(Int64LTEOptional, a, b);
  }
}
