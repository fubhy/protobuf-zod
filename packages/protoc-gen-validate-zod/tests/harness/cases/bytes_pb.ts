// @generated by protoc-gen-es v0.2.1 with parameter "target=ts"
// @generated from file tests/harness/cases/bytes.proto (package tests.harness.cases, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3} from "@bufbuild/protobuf";

/**
 * @generated from message tests.harness.cases.BytesNone
 */
export class BytesNone extends Message<BytesNone> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesNone {
    return new BytesNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesNone {
    return new BytesNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesNone {
    return new BytesNone().fromJsonString(jsonString, options);
  }

  static equals(a: BytesNone | PlainMessage<BytesNone> | undefined, b: BytesNone | PlainMessage<BytesNone> | undefined): boolean {
    return proto3.util.equals(BytesNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesConst
 */
export class BytesConst extends Message<BytesConst> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesConst>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesConst";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesConst {
    return new BytesConst().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesConst {
    return new BytesConst().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesConst {
    return new BytesConst().fromJsonString(jsonString, options);
  }

  static equals(a: BytesConst | PlainMessage<BytesConst> | undefined, b: BytesConst | PlainMessage<BytesConst> | undefined): boolean {
    return proto3.util.equals(BytesConst, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesIn
 */
export class BytesIn extends Message<BytesIn> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesIn {
    return new BytesIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesIn {
    return new BytesIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesIn {
    return new BytesIn().fromJsonString(jsonString, options);
  }

  static equals(a: BytesIn | PlainMessage<BytesIn> | undefined, b: BytesIn | PlainMessage<BytesIn> | undefined): boolean {
    return proto3.util.equals(BytesIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesNotIn
 */
export class BytesNotIn extends Message<BytesNotIn> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesNotIn {
    return new BytesNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesNotIn {
    return new BytesNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesNotIn {
    return new BytesNotIn().fromJsonString(jsonString, options);
  }

  static equals(a: BytesNotIn | PlainMessage<BytesNotIn> | undefined, b: BytesNotIn | PlainMessage<BytesNotIn> | undefined): boolean {
    return proto3.util.equals(BytesNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesLen
 */
export class BytesLen extends Message<BytesLen> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesLen {
    return new BytesLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesLen {
    return new BytesLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesLen {
    return new BytesLen().fromJsonString(jsonString, options);
  }

  static equals(a: BytesLen | PlainMessage<BytesLen> | undefined, b: BytesLen | PlainMessage<BytesLen> | undefined): boolean {
    return proto3.util.equals(BytesLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesMinLen
 */
export class BytesMinLen extends Message<BytesMinLen> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesMinLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesMinLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesMinLen {
    return new BytesMinLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesMinLen {
    return new BytesMinLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesMinLen {
    return new BytesMinLen().fromJsonString(jsonString, options);
  }

  static equals(a: BytesMinLen | PlainMessage<BytesMinLen> | undefined, b: BytesMinLen | PlainMessage<BytesMinLen> | undefined): boolean {
    return proto3.util.equals(BytesMinLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesMaxLen
 */
export class BytesMaxLen extends Message<BytesMaxLen> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesMaxLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesMaxLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesMaxLen {
    return new BytesMaxLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesMaxLen {
    return new BytesMaxLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesMaxLen {
    return new BytesMaxLen().fromJsonString(jsonString, options);
  }

  static equals(a: BytesMaxLen | PlainMessage<BytesMaxLen> | undefined, b: BytesMaxLen | PlainMessage<BytesMaxLen> | undefined): boolean {
    return proto3.util.equals(BytesMaxLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesMinMaxLen
 */
export class BytesMinMaxLen extends Message<BytesMinMaxLen> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesMinMaxLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesMinMaxLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesMinMaxLen {
    return new BytesMinMaxLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesMinMaxLen {
    return new BytesMinMaxLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesMinMaxLen {
    return new BytesMinMaxLen().fromJsonString(jsonString, options);
  }

  static equals(a: BytesMinMaxLen | PlainMessage<BytesMinMaxLen> | undefined, b: BytesMinMaxLen | PlainMessage<BytesMinMaxLen> | undefined): boolean {
    return proto3.util.equals(BytesMinMaxLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesEqualMinMaxLen
 */
export class BytesEqualMinMaxLen extends Message<BytesEqualMinMaxLen> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesEqualMinMaxLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesEqualMinMaxLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesEqualMinMaxLen {
    return new BytesEqualMinMaxLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesEqualMinMaxLen {
    return new BytesEqualMinMaxLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesEqualMinMaxLen {
    return new BytesEqualMinMaxLen().fromJsonString(jsonString, options);
  }

  static equals(a: BytesEqualMinMaxLen | PlainMessage<BytesEqualMinMaxLen> | undefined, b: BytesEqualMinMaxLen | PlainMessage<BytesEqualMinMaxLen> | undefined): boolean {
    return proto3.util.equals(BytesEqualMinMaxLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesPattern
 */
export class BytesPattern extends Message<BytesPattern> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesPattern";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesPattern {
    return new BytesPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesPattern {
    return new BytesPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesPattern {
    return new BytesPattern().fromJsonString(jsonString, options);
  }

  static equals(a: BytesPattern | PlainMessage<BytesPattern> | undefined, b: BytesPattern | PlainMessage<BytesPattern> | undefined): boolean {
    return proto3.util.equals(BytesPattern, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesPrefix
 */
export class BytesPrefix extends Message<BytesPrefix> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesPrefix>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesPrefix";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesPrefix {
    return new BytesPrefix().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesPrefix {
    return new BytesPrefix().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesPrefix {
    return new BytesPrefix().fromJsonString(jsonString, options);
  }

  static equals(a: BytesPrefix | PlainMessage<BytesPrefix> | undefined, b: BytesPrefix | PlainMessage<BytesPrefix> | undefined): boolean {
    return proto3.util.equals(BytesPrefix, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesContains
 */
export class BytesContains extends Message<BytesContains> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesContains>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesContains";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesContains {
    return new BytesContains().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesContains {
    return new BytesContains().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesContains {
    return new BytesContains().fromJsonString(jsonString, options);
  }

  static equals(a: BytesContains | PlainMessage<BytesContains> | undefined, b: BytesContains | PlainMessage<BytesContains> | undefined): boolean {
    return proto3.util.equals(BytesContains, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesSuffix
 */
export class BytesSuffix extends Message<BytesSuffix> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesSuffix>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesSuffix";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesSuffix {
    return new BytesSuffix().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesSuffix {
    return new BytesSuffix().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesSuffix {
    return new BytesSuffix().fromJsonString(jsonString, options);
  }

  static equals(a: BytesSuffix | PlainMessage<BytesSuffix> | undefined, b: BytesSuffix | PlainMessage<BytesSuffix> | undefined): boolean {
    return proto3.util.equals(BytesSuffix, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesIP
 */
export class BytesIP extends Message<BytesIP> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesIP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesIP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesIP {
    return new BytesIP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesIP {
    return new BytesIP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesIP {
    return new BytesIP().fromJsonString(jsonString, options);
  }

  static equals(a: BytesIP | PlainMessage<BytesIP> | undefined, b: BytesIP | PlainMessage<BytesIP> | undefined): boolean {
    return proto3.util.equals(BytesIP, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesIPv4
 */
export class BytesIPv4 extends Message<BytesIPv4> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesIPv4>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesIPv4";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesIPv4 {
    return new BytesIPv4().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesIPv4 {
    return new BytesIPv4().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesIPv4 {
    return new BytesIPv4().fromJsonString(jsonString, options);
  }

  static equals(a: BytesIPv4 | PlainMessage<BytesIPv4> | undefined, b: BytesIPv4 | PlainMessage<BytesIPv4> | undefined): boolean {
    return proto3.util.equals(BytesIPv4, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesIPv6
 */
export class BytesIPv6 extends Message<BytesIPv6> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesIPv6>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesIPv6";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesIPv6 {
    return new BytesIPv6().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesIPv6 {
    return new BytesIPv6().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesIPv6 {
    return new BytesIPv6().fromJsonString(jsonString, options);
  }

  static equals(a: BytesIPv6 | PlainMessage<BytesIPv6> | undefined, b: BytesIPv6 | PlainMessage<BytesIPv6> | undefined): boolean {
    return proto3.util.equals(BytesIPv6, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.BytesIPv6Ignore
 */
export class BytesIPv6Ignore extends Message<BytesIPv6Ignore> {
  /**
   * @generated from field: bytes val = 1;
   */
  val = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesIPv6Ignore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.BytesIPv6Ignore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesIPv6Ignore {
    return new BytesIPv6Ignore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesIPv6Ignore {
    return new BytesIPv6Ignore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesIPv6Ignore {
    return new BytesIPv6Ignore().fromJsonString(jsonString, options);
  }

  static equals(a: BytesIPv6Ignore | PlainMessage<BytesIPv6Ignore> | undefined, b: BytesIPv6Ignore | PlainMessage<BytesIPv6Ignore> | undefined): boolean {
    return proto3.util.equals(BytesIPv6Ignore, a, b);
  }
}

