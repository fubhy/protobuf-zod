// @generated by protoc-gen-es v0.2.1 with parameter "target=ts"
// @generated from file tests/harness/cases/strings.proto (package tests.harness.cases, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3} from "@bufbuild/protobuf";

/**
 * @generated from message tests.harness.cases.StringNone
 */
export class StringNone extends Message<StringNone> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringNone {
    return new StringNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringNone {
    return new StringNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringNone {
    return new StringNone().fromJsonString(jsonString, options);
  }

  static equals(a: StringNone | PlainMessage<StringNone> | undefined, b: StringNone | PlainMessage<StringNone> | undefined): boolean {
    return proto3.util.equals(StringNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringConst
 */
export class StringConst extends Message<StringConst> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringConst>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringConst";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringConst {
    return new StringConst().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringConst {
    return new StringConst().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringConst {
    return new StringConst().fromJsonString(jsonString, options);
  }

  static equals(a: StringConst | PlainMessage<StringConst> | undefined, b: StringConst | PlainMessage<StringConst> | undefined): boolean {
    return proto3.util.equals(StringConst, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringIn
 */
export class StringIn extends Message<StringIn> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringIn {
    return new StringIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringIn {
    return new StringIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringIn {
    return new StringIn().fromJsonString(jsonString, options);
  }

  static equals(a: StringIn | PlainMessage<StringIn> | undefined, b: StringIn | PlainMessage<StringIn> | undefined): boolean {
    return proto3.util.equals(StringIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringNotIn
 */
export class StringNotIn extends Message<StringNotIn> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringNotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringNotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringNotIn {
    return new StringNotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringNotIn {
    return new StringNotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringNotIn {
    return new StringNotIn().fromJsonString(jsonString, options);
  }

  static equals(a: StringNotIn | PlainMessage<StringNotIn> | undefined, b: StringNotIn | PlainMessage<StringNotIn> | undefined): boolean {
    return proto3.util.equals(StringNotIn, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringLen
 */
export class StringLen extends Message<StringLen> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringLen {
    return new StringLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringLen {
    return new StringLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringLen {
    return new StringLen().fromJsonString(jsonString, options);
  }

  static equals(a: StringLen | PlainMessage<StringLen> | undefined, b: StringLen | PlainMessage<StringLen> | undefined): boolean {
    return proto3.util.equals(StringLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringMinLen
 */
export class StringMinLen extends Message<StringMinLen> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringMinLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringMinLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringMinLen {
    return new StringMinLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringMinLen {
    return new StringMinLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringMinLen {
    return new StringMinLen().fromJsonString(jsonString, options);
  }

  static equals(a: StringMinLen | PlainMessage<StringMinLen> | undefined, b: StringMinLen | PlainMessage<StringMinLen> | undefined): boolean {
    return proto3.util.equals(StringMinLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringMaxLen
 */
export class StringMaxLen extends Message<StringMaxLen> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringMaxLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringMaxLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringMaxLen {
    return new StringMaxLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringMaxLen {
    return new StringMaxLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringMaxLen {
    return new StringMaxLen().fromJsonString(jsonString, options);
  }

  static equals(a: StringMaxLen | PlainMessage<StringMaxLen> | undefined, b: StringMaxLen | PlainMessage<StringMaxLen> | undefined): boolean {
    return proto3.util.equals(StringMaxLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringMinMaxLen
 */
export class StringMinMaxLen extends Message<StringMinMaxLen> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringMinMaxLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringMinMaxLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringMinMaxLen {
    return new StringMinMaxLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringMinMaxLen {
    return new StringMinMaxLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringMinMaxLen {
    return new StringMinMaxLen().fromJsonString(jsonString, options);
  }

  static equals(a: StringMinMaxLen | PlainMessage<StringMinMaxLen> | undefined, b: StringMinMaxLen | PlainMessage<StringMinMaxLen> | undefined): boolean {
    return proto3.util.equals(StringMinMaxLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringEqualMinMaxLen
 */
export class StringEqualMinMaxLen extends Message<StringEqualMinMaxLen> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringEqualMinMaxLen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringEqualMinMaxLen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringEqualMinMaxLen {
    return new StringEqualMinMaxLen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringEqualMinMaxLen {
    return new StringEqualMinMaxLen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringEqualMinMaxLen {
    return new StringEqualMinMaxLen().fromJsonString(jsonString, options);
  }

  static equals(a: StringEqualMinMaxLen | PlainMessage<StringEqualMinMaxLen> | undefined, b: StringEqualMinMaxLen | PlainMessage<StringEqualMinMaxLen> | undefined): boolean {
    return proto3.util.equals(StringEqualMinMaxLen, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringLenBytes
 */
export class StringLenBytes extends Message<StringLenBytes> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringLenBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringLenBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringLenBytes {
    return new StringLenBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringLenBytes {
    return new StringLenBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringLenBytes {
    return new StringLenBytes().fromJsonString(jsonString, options);
  }

  static equals(a: StringLenBytes | PlainMessage<StringLenBytes> | undefined, b: StringLenBytes | PlainMessage<StringLenBytes> | undefined): boolean {
    return proto3.util.equals(StringLenBytes, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringMinBytes
 */
export class StringMinBytes extends Message<StringMinBytes> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringMinBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringMinBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringMinBytes {
    return new StringMinBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringMinBytes {
    return new StringMinBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringMinBytes {
    return new StringMinBytes().fromJsonString(jsonString, options);
  }

  static equals(a: StringMinBytes | PlainMessage<StringMinBytes> | undefined, b: StringMinBytes | PlainMessage<StringMinBytes> | undefined): boolean {
    return proto3.util.equals(StringMinBytes, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringMaxBytes
 */
export class StringMaxBytes extends Message<StringMaxBytes> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringMaxBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringMaxBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringMaxBytes {
    return new StringMaxBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringMaxBytes {
    return new StringMaxBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringMaxBytes {
    return new StringMaxBytes().fromJsonString(jsonString, options);
  }

  static equals(a: StringMaxBytes | PlainMessage<StringMaxBytes> | undefined, b: StringMaxBytes | PlainMessage<StringMaxBytes> | undefined): boolean {
    return proto3.util.equals(StringMaxBytes, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringMinMaxBytes
 */
export class StringMinMaxBytes extends Message<StringMinMaxBytes> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringMinMaxBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringMinMaxBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringMinMaxBytes {
    return new StringMinMaxBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringMinMaxBytes {
    return new StringMinMaxBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringMinMaxBytes {
    return new StringMinMaxBytes().fromJsonString(jsonString, options);
  }

  static equals(a: StringMinMaxBytes | PlainMessage<StringMinMaxBytes> | undefined, b: StringMinMaxBytes | PlainMessage<StringMinMaxBytes> | undefined): boolean {
    return proto3.util.equals(StringMinMaxBytes, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringEqualMinMaxBytes
 */
export class StringEqualMinMaxBytes extends Message<StringEqualMinMaxBytes> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringEqualMinMaxBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringEqualMinMaxBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringEqualMinMaxBytes {
    return new StringEqualMinMaxBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringEqualMinMaxBytes {
    return new StringEqualMinMaxBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringEqualMinMaxBytes {
    return new StringEqualMinMaxBytes().fromJsonString(jsonString, options);
  }

  static equals(a: StringEqualMinMaxBytes | PlainMessage<StringEqualMinMaxBytes> | undefined, b: StringEqualMinMaxBytes | PlainMessage<StringEqualMinMaxBytes> | undefined): boolean {
    return proto3.util.equals(StringEqualMinMaxBytes, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringPattern
 */
export class StringPattern extends Message<StringPattern> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringPattern";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringPattern {
    return new StringPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringPattern {
    return new StringPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringPattern {
    return new StringPattern().fromJsonString(jsonString, options);
  }

  static equals(a: StringPattern | PlainMessage<StringPattern> | undefined, b: StringPattern | PlainMessage<StringPattern> | undefined): boolean {
    return proto3.util.equals(StringPattern, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringPatternEscapes
 */
export class StringPatternEscapes extends Message<StringPatternEscapes> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringPatternEscapes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringPatternEscapes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringPatternEscapes {
    return new StringPatternEscapes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringPatternEscapes {
    return new StringPatternEscapes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringPatternEscapes {
    return new StringPatternEscapes().fromJsonString(jsonString, options);
  }

  static equals(a: StringPatternEscapes | PlainMessage<StringPatternEscapes> | undefined, b: StringPatternEscapes | PlainMessage<StringPatternEscapes> | undefined): boolean {
    return proto3.util.equals(StringPatternEscapes, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringPrefix
 */
export class StringPrefix extends Message<StringPrefix> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringPrefix>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringPrefix";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringPrefix {
    return new StringPrefix().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringPrefix {
    return new StringPrefix().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringPrefix {
    return new StringPrefix().fromJsonString(jsonString, options);
  }

  static equals(a: StringPrefix | PlainMessage<StringPrefix> | undefined, b: StringPrefix | PlainMessage<StringPrefix> | undefined): boolean {
    return proto3.util.equals(StringPrefix, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringContains
 */
export class StringContains extends Message<StringContains> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringContains>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringContains";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringContains {
    return new StringContains().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringContains {
    return new StringContains().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringContains {
    return new StringContains().fromJsonString(jsonString, options);
  }

  static equals(a: StringContains | PlainMessage<StringContains> | undefined, b: StringContains | PlainMessage<StringContains> | undefined): boolean {
    return proto3.util.equals(StringContains, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringNotContains
 */
export class StringNotContains extends Message<StringNotContains> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringNotContains>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringNotContains";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringNotContains {
    return new StringNotContains().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringNotContains {
    return new StringNotContains().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringNotContains {
    return new StringNotContains().fromJsonString(jsonString, options);
  }

  static equals(a: StringNotContains | PlainMessage<StringNotContains> | undefined, b: StringNotContains | PlainMessage<StringNotContains> | undefined): boolean {
    return proto3.util.equals(StringNotContains, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringSuffix
 */
export class StringSuffix extends Message<StringSuffix> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringSuffix>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringSuffix";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringSuffix {
    return new StringSuffix().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringSuffix {
    return new StringSuffix().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringSuffix {
    return new StringSuffix().fromJsonString(jsonString, options);
  }

  static equals(a: StringSuffix | PlainMessage<StringSuffix> | undefined, b: StringSuffix | PlainMessage<StringSuffix> | undefined): boolean {
    return proto3.util.equals(StringSuffix, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringEmail
 */
export class StringEmail extends Message<StringEmail> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringEmail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringEmail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringEmail {
    return new StringEmail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringEmail {
    return new StringEmail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringEmail {
    return new StringEmail().fromJsonString(jsonString, options);
  }

  static equals(a: StringEmail | PlainMessage<StringEmail> | undefined, b: StringEmail | PlainMessage<StringEmail> | undefined): boolean {
    return proto3.util.equals(StringEmail, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringAddress
 */
export class StringAddress extends Message<StringAddress> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringAddress {
    return new StringAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringAddress {
    return new StringAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringAddress {
    return new StringAddress().fromJsonString(jsonString, options);
  }

  static equals(a: StringAddress | PlainMessage<StringAddress> | undefined, b: StringAddress | PlainMessage<StringAddress> | undefined): boolean {
    return proto3.util.equals(StringAddress, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringHostname
 */
export class StringHostname extends Message<StringHostname> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringHostname>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringHostname";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringHostname {
    return new StringHostname().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringHostname {
    return new StringHostname().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringHostname {
    return new StringHostname().fromJsonString(jsonString, options);
  }

  static equals(a: StringHostname | PlainMessage<StringHostname> | undefined, b: StringHostname | PlainMessage<StringHostname> | undefined): boolean {
    return proto3.util.equals(StringHostname, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringIP
 */
export class StringIP extends Message<StringIP> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringIP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringIP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringIP {
    return new StringIP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringIP {
    return new StringIP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringIP {
    return new StringIP().fromJsonString(jsonString, options);
  }

  static equals(a: StringIP | PlainMessage<StringIP> | undefined, b: StringIP | PlainMessage<StringIP> | undefined): boolean {
    return proto3.util.equals(StringIP, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringIPv4
 */
export class StringIPv4 extends Message<StringIPv4> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringIPv4>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringIPv4";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringIPv4 {
    return new StringIPv4().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringIPv4 {
    return new StringIPv4().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringIPv4 {
    return new StringIPv4().fromJsonString(jsonString, options);
  }

  static equals(a: StringIPv4 | PlainMessage<StringIPv4> | undefined, b: StringIPv4 | PlainMessage<StringIPv4> | undefined): boolean {
    return proto3.util.equals(StringIPv4, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringIPv6
 */
export class StringIPv6 extends Message<StringIPv6> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringIPv6>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringIPv6";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringIPv6 {
    return new StringIPv6().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringIPv6 {
    return new StringIPv6().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringIPv6 {
    return new StringIPv6().fromJsonString(jsonString, options);
  }

  static equals(a: StringIPv6 | PlainMessage<StringIPv6> | undefined, b: StringIPv6 | PlainMessage<StringIPv6> | undefined): boolean {
    return proto3.util.equals(StringIPv6, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringURI
 */
export class StringURI extends Message<StringURI> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringURI>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringURI";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringURI {
    return new StringURI().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringURI {
    return new StringURI().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringURI {
    return new StringURI().fromJsonString(jsonString, options);
  }

  static equals(a: StringURI | PlainMessage<StringURI> | undefined, b: StringURI | PlainMessage<StringURI> | undefined): boolean {
    return proto3.util.equals(StringURI, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringURIRef
 */
export class StringURIRef extends Message<StringURIRef> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringURIRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringURIRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringURIRef {
    return new StringURIRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringURIRef {
    return new StringURIRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringURIRef {
    return new StringURIRef().fromJsonString(jsonString, options);
  }

  static equals(a: StringURIRef | PlainMessage<StringURIRef> | undefined, b: StringURIRef | PlainMessage<StringURIRef> | undefined): boolean {
    return proto3.util.equals(StringURIRef, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringUUID
 */
export class StringUUID extends Message<StringUUID> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringUUID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringUUID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringUUID {
    return new StringUUID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringUUID {
    return new StringUUID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringUUID {
    return new StringUUID().fromJsonString(jsonString, options);
  }

  static equals(a: StringUUID | PlainMessage<StringUUID> | undefined, b: StringUUID | PlainMessage<StringUUID> | undefined): boolean {
    return proto3.util.equals(StringUUID, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringHttpHeaderName
 */
export class StringHttpHeaderName extends Message<StringHttpHeaderName> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringHttpHeaderName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringHttpHeaderName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringHttpHeaderName {
    return new StringHttpHeaderName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringHttpHeaderName {
    return new StringHttpHeaderName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringHttpHeaderName {
    return new StringHttpHeaderName().fromJsonString(jsonString, options);
  }

  static equals(a: StringHttpHeaderName | PlainMessage<StringHttpHeaderName> | undefined, b: StringHttpHeaderName | PlainMessage<StringHttpHeaderName> | undefined): boolean {
    return proto3.util.equals(StringHttpHeaderName, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringHttpHeaderValue
 */
export class StringHttpHeaderValue extends Message<StringHttpHeaderValue> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringHttpHeaderValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringHttpHeaderValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringHttpHeaderValue {
    return new StringHttpHeaderValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringHttpHeaderValue {
    return new StringHttpHeaderValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringHttpHeaderValue {
    return new StringHttpHeaderValue().fromJsonString(jsonString, options);
  }

  static equals(a: StringHttpHeaderValue | PlainMessage<StringHttpHeaderValue> | undefined, b: StringHttpHeaderValue | PlainMessage<StringHttpHeaderValue> | undefined): boolean {
    return proto3.util.equals(StringHttpHeaderValue, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringValidHeader
 */
export class StringValidHeader extends Message<StringValidHeader> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringValidHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringValidHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringValidHeader {
    return new StringValidHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringValidHeader {
    return new StringValidHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringValidHeader {
    return new StringValidHeader().fromJsonString(jsonString, options);
  }

  static equals(a: StringValidHeader | PlainMessage<StringValidHeader> | undefined, b: StringValidHeader | PlainMessage<StringValidHeader> | undefined): boolean {
    return proto3.util.equals(StringValidHeader, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringUUIDIgnore
 */
export class StringUUIDIgnore extends Message<StringUUIDIgnore> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<StringUUIDIgnore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringUUIDIgnore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringUUIDIgnore {
    return new StringUUIDIgnore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringUUIDIgnore {
    return new StringUUIDIgnore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringUUIDIgnore {
    return new StringUUIDIgnore().fromJsonString(jsonString, options);
  }

  static equals(a: StringUUIDIgnore | PlainMessage<StringUUIDIgnore> | undefined, b: StringUUIDIgnore | PlainMessage<StringUUIDIgnore> | undefined): boolean {
    return proto3.util.equals(StringUUIDIgnore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.StringInOneOf
 */
export class StringInOneOf extends Message<StringInOneOf> {
  /**
   * @generated from oneof tests.harness.cases.StringInOneOf.foo
   */
  foo: {
    /**
     * @generated from field: string bar = 1;
     */
    value: string;
    case: "bar";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StringInOneOf>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.StringInOneOf";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bar", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "foo" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringInOneOf {
    return new StringInOneOf().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringInOneOf {
    return new StringInOneOf().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringInOneOf {
    return new StringInOneOf().fromJsonString(jsonString, options);
  }

  static equals(a: StringInOneOf | PlainMessage<StringInOneOf> | undefined, b: StringInOneOf | PlainMessage<StringInOneOf> | undefined): boolean {
    return proto3.util.equals(StringInOneOf, a, b);
  }
}

