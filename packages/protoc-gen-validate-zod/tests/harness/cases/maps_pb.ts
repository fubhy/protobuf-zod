// @generated by protoc-gen-es v0.2.1 with parameter "target=ts"
// @generated from file tests/harness/cases/maps.proto (package tests.harness.cases, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message tests.harness.cases.MapNone
 */
export class MapNone extends Message<MapNone> {
  /**
   * @generated from field: map<uint32, bool> val = 1;
   */
  val: { [key: number]: boolean } = {};

  constructor(data?: PartialMessage<MapNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 13 /* ScalarType.UINT32 */,
      V: { kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapNone {
    return new MapNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapNone {
    return new MapNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapNone {
    return new MapNone().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapNone | PlainMessage<MapNone> | undefined,
    b: MapNone | PlainMessage<MapNone> | undefined
  ): boolean {
    return proto3.util.equals(MapNone, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapMin
 */
export class MapMin extends Message<MapMin> {
  /**
   * @generated from field: map<int32, float> val = 1;
   */
  val: { [key: number]: number } = {};

  constructor(data?: PartialMessage<MapMin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapMin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 5 /* ScalarType.INT32 */,
      V: { kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapMin {
    return new MapMin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapMin {
    return new MapMin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapMin {
    return new MapMin().fromJsonString(jsonString, options);
  }

  static equals(a: MapMin | PlainMessage<MapMin> | undefined, b: MapMin | PlainMessage<MapMin> | undefined): boolean {
    return proto3.util.equals(MapMin, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapMax
 */
export class MapMax extends Message<MapMax> {
  /**
   * @generated from field: map<int64, double> val = 1;
   */
  val: { [key: string]: number } = {};

  constructor(data?: PartialMessage<MapMax>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapMax";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 3 /* ScalarType.INT64 */,
      V: { kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapMax {
    return new MapMax().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapMax {
    return new MapMax().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapMax {
    return new MapMax().fromJsonString(jsonString, options);
  }

  static equals(a: MapMax | PlainMessage<MapMax> | undefined, b: MapMax | PlainMessage<MapMax> | undefined): boolean {
    return proto3.util.equals(MapMax, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapMinMax
 */
export class MapMinMax extends Message<MapMinMax> {
  /**
   * @generated from field: map<string, bool> val = 1;
   */
  val: { [key: string]: boolean } = {};

  constructor(data?: PartialMessage<MapMinMax>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapMinMax";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapMinMax {
    return new MapMinMax().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapMinMax {
    return new MapMinMax().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapMinMax {
    return new MapMinMax().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapMinMax | PlainMessage<MapMinMax> | undefined,
    b: MapMinMax | PlainMessage<MapMinMax> | undefined
  ): boolean {
    return proto3.util.equals(MapMinMax, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapExact
 */
export class MapExact extends Message<MapExact> {
  /**
   * @generated from field: map<uint64, string> val = 1;
   */
  val: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapExact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapExact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 4 /* ScalarType.UINT64 */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapExact {
    return new MapExact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapExact {
    return new MapExact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapExact {
    return new MapExact().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapExact | PlainMessage<MapExact> | undefined,
    b: MapExact | PlainMessage<MapExact> | undefined
  ): boolean {
    return proto3.util.equals(MapExact, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapNoSparse
 */
export class MapNoSparse extends Message<MapNoSparse> {
  /**
   * @generated from field: map<uint32, tests.harness.cases.MapNoSparse.Msg> val = 1;
   */
  val: { [key: number]: MapNoSparse_Msg } = {};

  constructor(data?: PartialMessage<MapNoSparse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapNoSparse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "map", K: 13 /* ScalarType.UINT32 */, V: { kind: "message", T: MapNoSparse_Msg } },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapNoSparse {
    return new MapNoSparse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapNoSparse {
    return new MapNoSparse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapNoSparse {
    return new MapNoSparse().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapNoSparse | PlainMessage<MapNoSparse> | undefined,
    b: MapNoSparse | PlainMessage<MapNoSparse> | undefined
  ): boolean {
    return proto3.util.equals(MapNoSparse, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapNoSparse.Msg
 */
export class MapNoSparse_Msg extends Message<MapNoSparse_Msg> {
  constructor(data?: PartialMessage<MapNoSparse_Msg>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapNoSparse.Msg";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapNoSparse_Msg {
    return new MapNoSparse_Msg().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapNoSparse_Msg {
    return new MapNoSparse_Msg().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapNoSparse_Msg {
    return new MapNoSparse_Msg().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapNoSparse_Msg | PlainMessage<MapNoSparse_Msg> | undefined,
    b: MapNoSparse_Msg | PlainMessage<MapNoSparse_Msg> | undefined
  ): boolean {
    return proto3.util.equals(MapNoSparse_Msg, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapKeys
 */
export class MapKeys extends Message<MapKeys> {
  /**
   * @generated from field: map<sint64, string> val = 1;
   */
  val: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapKeys>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapKeys";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 18 /* ScalarType.SINT64 */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeys {
    return new MapKeys().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeys {
    return new MapKeys().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeys {
    return new MapKeys().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapKeys | PlainMessage<MapKeys> | undefined,
    b: MapKeys | PlainMessage<MapKeys> | undefined
  ): boolean {
    return proto3.util.equals(MapKeys, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapValues
 */
export class MapValues extends Message<MapValues> {
  /**
   * @generated from field: map<string, string> val = 1;
   */
  val: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapValues>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapValues";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapValues {
    return new MapValues().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapValues {
    return new MapValues().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapValues {
    return new MapValues().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapValues | PlainMessage<MapValues> | undefined,
    b: MapValues | PlainMessage<MapValues> | undefined
  ): boolean {
    return proto3.util.equals(MapValues, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapKeysPattern
 */
export class MapKeysPattern extends Message<MapKeysPattern> {
  /**
   * @generated from field: map<string, string> val = 1;
   */
  val: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapKeysPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapKeysPattern";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeysPattern {
    return new MapKeysPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeysPattern {
    return new MapKeysPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeysPattern {
    return new MapKeysPattern().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapKeysPattern | PlainMessage<MapKeysPattern> | undefined,
    b: MapKeysPattern | PlainMessage<MapKeysPattern> | undefined
  ): boolean {
    return proto3.util.equals(MapKeysPattern, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapValuesPattern
 */
export class MapValuesPattern extends Message<MapValuesPattern> {
  /**
   * @generated from field: map<string, string> val = 1;
   */
  val: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapValuesPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapValuesPattern";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapValuesPattern {
    return new MapValuesPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapValuesPattern {
    return new MapValuesPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapValuesPattern {
    return new MapValuesPattern().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapValuesPattern | PlainMessage<MapValuesPattern> | undefined,
    b: MapValuesPattern | PlainMessage<MapValuesPattern> | undefined
  ): boolean {
    return proto3.util.equals(MapValuesPattern, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapRecursive
 */
export class MapRecursive extends Message<MapRecursive> {
  /**
   * @generated from field: map<uint32, tests.harness.cases.MapRecursive.Msg> val = 1;
   */
  val: { [key: number]: MapRecursive_Msg } = {};

  constructor(data?: PartialMessage<MapRecursive>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapRecursive";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "map", K: 13 /* ScalarType.UINT32 */, V: { kind: "message", T: MapRecursive_Msg } },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapRecursive {
    return new MapRecursive().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapRecursive {
    return new MapRecursive().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapRecursive {
    return new MapRecursive().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapRecursive | PlainMessage<MapRecursive> | undefined,
    b: MapRecursive | PlainMessage<MapRecursive> | undefined
  ): boolean {
    return proto3.util.equals(MapRecursive, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapRecursive.Msg
 */
export class MapRecursive_Msg extends Message<MapRecursive_Msg> {
  /**
   * @generated from field: string val = 1;
   */
  val = "";

  constructor(data?: PartialMessage<MapRecursive_Msg>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapRecursive.Msg";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapRecursive_Msg {
    return new MapRecursive_Msg().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapRecursive_Msg {
    return new MapRecursive_Msg().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapRecursive_Msg {
    return new MapRecursive_Msg().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapRecursive_Msg | PlainMessage<MapRecursive_Msg> | undefined,
    b: MapRecursive_Msg | PlainMessage<MapRecursive_Msg> | undefined
  ): boolean {
    return proto3.util.equals(MapRecursive_Msg, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MapExactIgnore
 */
export class MapExactIgnore extends Message<MapExactIgnore> {
  /**
   * @generated from field: map<uint64, string> val = 1;
   */
  val: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapExactIgnore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MapExactIgnore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "val",
      kind: "map",
      K: 4 /* ScalarType.UINT64 */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapExactIgnore {
    return new MapExactIgnore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapExactIgnore {
    return new MapExactIgnore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapExactIgnore {
    return new MapExactIgnore().fromJsonString(jsonString, options);
  }

  static equals(
    a: MapExactIgnore | PlainMessage<MapExactIgnore> | undefined,
    b: MapExactIgnore | PlainMessage<MapExactIgnore> | undefined
  ): boolean {
    return proto3.util.equals(MapExactIgnore, a, b);
  }
}

/**
 * @generated from message tests.harness.cases.MultipleMaps
 */
export class MultipleMaps extends Message<MultipleMaps> {
  /**
   * @generated from field: map<uint32, string> first = 1;
   */
  first: { [key: number]: string } = {};

  /**
   * @generated from field: map<int32, bool> second = 2;
   */
  second: { [key: number]: boolean } = {};

  /**
   * @generated from field: map<int32, bool> third = 3;
   */
  third: { [key: number]: boolean } = {};

  constructor(data?: PartialMessage<MultipleMaps>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "tests.harness.cases.MultipleMaps";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "first",
      kind: "map",
      K: 13 /* ScalarType.UINT32 */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
    {
      no: 2,
      name: "second",
      kind: "map",
      K: 5 /* ScalarType.INT32 */,
      V: { kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    },
    {
      no: 3,
      name: "third",
      kind: "map",
      K: 5 /* ScalarType.INT32 */,
      V: { kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultipleMaps {
    return new MultipleMaps().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultipleMaps {
    return new MultipleMaps().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultipleMaps {
    return new MultipleMaps().fromJsonString(jsonString, options);
  }

  static equals(
    a: MultipleMaps | PlainMessage<MultipleMaps> | undefined,
    b: MultipleMaps | PlainMessage<MultipleMaps> | undefined
  ): boolean {
    return proto3.util.equals(MultipleMaps, a, b);
  }
}
